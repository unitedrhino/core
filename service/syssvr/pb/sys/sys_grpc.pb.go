// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.19.4
// source: proto/sys.proto

package sys

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	UserManage_UserInfoCreate_FullMethodName      = "/sys.UserManage/userInfoCreate"
	UserManage_UserInfoIndex_FullMethodName       = "/sys.UserManage/userInfoIndex"
	UserManage_UserInfoUpdate_FullMethodName      = "/sys.UserManage/userInfoUpdate"
	UserManage_UserInfoRead_FullMethodName        = "/sys.UserManage/userInfoRead"
	UserManage_UserInfoDelete_FullMethodName      = "/sys.UserManage/userInfoDelete"
	UserManage_UserLogin_FullMethodName           = "/sys.UserManage/userLogin"
	UserManage_UserForgetPwd_FullMethodName       = "/sys.UserManage/userForgetPwd"
	UserManage_UserCaptcha_FullMethodName         = "/sys.UserManage/userCaptcha"
	UserManage_UserCheckToken_FullMethodName      = "/sys.UserManage/userCheckToken"
	UserManage_UserRegister_FullMethodName        = "/sys.UserManage/userRegister"
	UserManage_UserChangePwd_FullMethodName       = "/sys.UserManage/userChangePwd"
	UserManage_UserRoleIndex_FullMethodName       = "/sys.UserManage/userRoleIndex"
	UserManage_UserRoleMultiUpdate_FullMethodName = "/sys.UserManage/userRoleMultiUpdate"
	UserManage_UserAreaApplyCreate_FullMethodName = "/sys.UserManage/userAreaApplyCreate"
)

// UserManageClient is the client API for UserManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserManageClient interface {
	UserInfoCreate(ctx context.Context, in *UserInfoCreateReq, opts ...grpc.CallOption) (*UserCreateResp, error)
	UserInfoIndex(ctx context.Context, in *UserInfoIndexReq, opts ...grpc.CallOption) (*UserInfoIndexResp, error)
	UserInfoUpdate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*Response, error)
	UserInfoRead(ctx context.Context, in *UserInfoReadReq, opts ...grpc.CallOption) (*UserInfo, error)
	UserInfoDelete(ctx context.Context, in *UserInfoDeleteReq, opts ...grpc.CallOption) (*Response, error)
	UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error)
	UserForgetPwd(ctx context.Context, in *UserForgetPwdReq, opts ...grpc.CallOption) (*Response, error)
	UserCaptcha(ctx context.Context, in *UserCaptchaReq, opts ...grpc.CallOption) (*UserCaptchaResp, error)
	UserCheckToken(ctx context.Context, in *UserCheckTokenReq, opts ...grpc.CallOption) (*UserCheckTokenResp, error)
	UserRegister(ctx context.Context, in *UserRegisterReq, opts ...grpc.CallOption) (*UserRegisterResp, error)
	UserChangePwd(ctx context.Context, in *UserChangePwdReq, opts ...grpc.CallOption) (*Response, error)
	UserRoleIndex(ctx context.Context, in *UserRoleIndexReq, opts ...grpc.CallOption) (*UserRoleIndexResp, error)
	UserRoleMultiUpdate(ctx context.Context, in *UserRoleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	UserAreaApplyCreate(ctx context.Context, in *UserAreaApplyCreateReq, opts ...grpc.CallOption) (*Response, error)
}

type userManageClient struct {
	cc grpc.ClientConnInterface
}

func NewUserManageClient(cc grpc.ClientConnInterface) UserManageClient {
	return &userManageClient{cc}
}

func (c *userManageClient) UserInfoCreate(ctx context.Context, in *UserInfoCreateReq, opts ...grpc.CallOption) (*UserCreateResp, error) {
	out := new(UserCreateResp)
	err := c.cc.Invoke(ctx, UserManage_UserInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoIndex(ctx context.Context, in *UserInfoIndexReq, opts ...grpc.CallOption) (*UserInfoIndexResp, error) {
	out := new(UserInfoIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoUpdate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoRead(ctx context.Context, in *UserInfoReadReq, opts ...grpc.CallOption) (*UserInfo, error) {
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserManage_UserInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoDelete(ctx context.Context, in *UserInfoDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error) {
	out := new(UserLoginResp)
	err := c.cc.Invoke(ctx, UserManage_UserLogin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserForgetPwd(ctx context.Context, in *UserForgetPwdReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserForgetPwd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserCaptcha(ctx context.Context, in *UserCaptchaReq, opts ...grpc.CallOption) (*UserCaptchaResp, error) {
	out := new(UserCaptchaResp)
	err := c.cc.Invoke(ctx, UserManage_UserCaptcha_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserCheckToken(ctx context.Context, in *UserCheckTokenReq, opts ...grpc.CallOption) (*UserCheckTokenResp, error) {
	out := new(UserCheckTokenResp)
	err := c.cc.Invoke(ctx, UserManage_UserCheckToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRegister(ctx context.Context, in *UserRegisterReq, opts ...grpc.CallOption) (*UserRegisterResp, error) {
	out := new(UserRegisterResp)
	err := c.cc.Invoke(ctx, UserManage_UserRegister_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserChangePwd(ctx context.Context, in *UserChangePwdReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserChangePwd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRoleIndex(ctx context.Context, in *UserRoleIndexReq, opts ...grpc.CallOption) (*UserRoleIndexResp, error) {
	out := new(UserRoleIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserRoleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRoleMultiUpdate(ctx context.Context, in *UserRoleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserRoleMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserAreaApplyCreate(ctx context.Context, in *UserAreaApplyCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserAreaApplyCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserManageServer is the server API for UserManage service.
// All implementations must embed UnimplementedUserManageServer
// for forward compatibility
type UserManageServer interface {
	UserInfoCreate(context.Context, *UserInfoCreateReq) (*UserCreateResp, error)
	UserInfoIndex(context.Context, *UserInfoIndexReq) (*UserInfoIndexResp, error)
	UserInfoUpdate(context.Context, *UserInfo) (*Response, error)
	UserInfoRead(context.Context, *UserInfoReadReq) (*UserInfo, error)
	UserInfoDelete(context.Context, *UserInfoDeleteReq) (*Response, error)
	UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error)
	UserForgetPwd(context.Context, *UserForgetPwdReq) (*Response, error)
	UserCaptcha(context.Context, *UserCaptchaReq) (*UserCaptchaResp, error)
	UserCheckToken(context.Context, *UserCheckTokenReq) (*UserCheckTokenResp, error)
	UserRegister(context.Context, *UserRegisterReq) (*UserRegisterResp, error)
	UserChangePwd(context.Context, *UserChangePwdReq) (*Response, error)
	UserRoleIndex(context.Context, *UserRoleIndexReq) (*UserRoleIndexResp, error)
	UserRoleMultiUpdate(context.Context, *UserRoleMultiUpdateReq) (*Response, error)
	UserAreaApplyCreate(context.Context, *UserAreaApplyCreateReq) (*Response, error)
	mustEmbedUnimplementedUserManageServer()
}

// UnimplementedUserManageServer must be embedded to have forward compatible implementations.
type UnimplementedUserManageServer struct {
}

func (UnimplementedUserManageServer) UserInfoCreate(context.Context, *UserInfoCreateReq) (*UserCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoCreate not implemented")
}
func (UnimplementedUserManageServer) UserInfoIndex(context.Context, *UserInfoIndexReq) (*UserInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoIndex not implemented")
}
func (UnimplementedUserManageServer) UserInfoUpdate(context.Context, *UserInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoUpdate not implemented")
}
func (UnimplementedUserManageServer) UserInfoRead(context.Context, *UserInfoReadReq) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoRead not implemented")
}
func (UnimplementedUserManageServer) UserInfoDelete(context.Context, *UserInfoDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoDelete not implemented")
}
func (UnimplementedUserManageServer) UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedUserManageServer) UserForgetPwd(context.Context, *UserForgetPwdReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserForgetPwd not implemented")
}
func (UnimplementedUserManageServer) UserCaptcha(context.Context, *UserCaptchaReq) (*UserCaptchaResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCaptcha not implemented")
}
func (UnimplementedUserManageServer) UserCheckToken(context.Context, *UserCheckTokenReq) (*UserCheckTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCheckToken not implemented")
}
func (UnimplementedUserManageServer) UserRegister(context.Context, *UserRegisterReq) (*UserRegisterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister not implemented")
}
func (UnimplementedUserManageServer) UserChangePwd(context.Context, *UserChangePwdReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserChangePwd not implemented")
}
func (UnimplementedUserManageServer) UserRoleIndex(context.Context, *UserRoleIndexReq) (*UserRoleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRoleIndex not implemented")
}
func (UnimplementedUserManageServer) UserRoleMultiUpdate(context.Context, *UserRoleMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRoleMultiUpdate not implemented")
}
func (UnimplementedUserManageServer) UserAreaApplyCreate(context.Context, *UserAreaApplyCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAreaApplyCreate not implemented")
}
func (UnimplementedUserManageServer) mustEmbedUnimplementedUserManageServer() {}

// UnsafeUserManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserManageServer will
// result in compilation errors.
type UnsafeUserManageServer interface {
	mustEmbedUnimplementedUserManageServer()
}

func RegisterUserManageServer(s grpc.ServiceRegistrar, srv UserManageServer) {
	s.RegisterService(&UserManage_ServiceDesc, srv)
}

func _UserManage_UserInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoCreate(ctx, req.(*UserInfoCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoIndex(ctx, req.(*UserInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoUpdate(ctx, req.(*UserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoRead(ctx, req.(*UserInfoReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoDelete(ctx, req.(*UserInfoDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserLogin(ctx, req.(*UserLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserForgetPwd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserForgetPwdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserForgetPwd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserForgetPwd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserForgetPwd(ctx, req.(*UserForgetPwdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserCaptcha_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCaptchaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserCaptcha(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserCaptcha_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserCaptcha(ctx, req.(*UserCaptchaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserCheckToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCheckTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserCheckToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserCheckToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserCheckToken(ctx, req.(*UserCheckTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRegister(ctx, req.(*UserRegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserChangePwd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserChangePwdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserChangePwd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserChangePwd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserChangePwd(ctx, req.(*UserChangePwdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRoleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRoleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRoleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRoleIndex(ctx, req.(*UserRoleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRoleMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRoleMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRoleMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRoleMultiUpdate(ctx, req.(*UserRoleMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserAreaApplyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAreaApplyCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserAreaApplyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserAreaApplyCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserAreaApplyCreate(ctx, req.(*UserAreaApplyCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserManage_ServiceDesc is the grpc.ServiceDesc for UserManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.UserManage",
	HandlerType: (*UserManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "userInfoCreate",
			Handler:    _UserManage_UserInfoCreate_Handler,
		},
		{
			MethodName: "userInfoIndex",
			Handler:    _UserManage_UserInfoIndex_Handler,
		},
		{
			MethodName: "userInfoUpdate",
			Handler:    _UserManage_UserInfoUpdate_Handler,
		},
		{
			MethodName: "userInfoRead",
			Handler:    _UserManage_UserInfoRead_Handler,
		},
		{
			MethodName: "userInfoDelete",
			Handler:    _UserManage_UserInfoDelete_Handler,
		},
		{
			MethodName: "userLogin",
			Handler:    _UserManage_UserLogin_Handler,
		},
		{
			MethodName: "userForgetPwd",
			Handler:    _UserManage_UserForgetPwd_Handler,
		},
		{
			MethodName: "userCaptcha",
			Handler:    _UserManage_UserCaptcha_Handler,
		},
		{
			MethodName: "userCheckToken",
			Handler:    _UserManage_UserCheckToken_Handler,
		},
		{
			MethodName: "userRegister",
			Handler:    _UserManage_UserRegister_Handler,
		},
		{
			MethodName: "userChangePwd",
			Handler:    _UserManage_UserChangePwd_Handler,
		},
		{
			MethodName: "userRoleIndex",
			Handler:    _UserManage_UserRoleIndex_Handler,
		},
		{
			MethodName: "userRoleMultiUpdate",
			Handler:    _UserManage_UserRoleMultiUpdate_Handler,
		},
		{
			MethodName: "userAreaApplyCreate",
			Handler:    _UserManage_UserAreaApplyCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	DataManage_DataProjectMultiUpdate_FullMethodName = "/sys.DataManage/dataProjectMultiUpdate"
	DataManage_DataProjectIndex_FullMethodName       = "/sys.DataManage/dataProjectIndex"
	DataManage_DataAreaMultiUpdate_FullMethodName    = "/sys.DataManage/dataAreaMultiUpdate"
	DataManage_DataAreaIndex_FullMethodName          = "/sys.DataManage/dataAreaIndex"
	DataManage_DataAreaMultiDelete_FullMethodName    = "/sys.DataManage/dataAreaMultiDelete"
	DataManage_UserAreaApplyIndex_FullMethodName     = "/sys.DataManage/userAreaApplyIndex"
	DataManage_UserAreaApplyDeal_FullMethodName      = "/sys.DataManage/userAreaApplyDeal"
)

// DataManageClient is the client API for DataManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataManageClient interface {
	DataProjectMultiUpdate(ctx context.Context, in *DataProjectMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	DataProjectIndex(ctx context.Context, in *DataProjectIndexReq, opts ...grpc.CallOption) (*DataProjectIndexResp, error)
	DataAreaMultiUpdate(ctx context.Context, in *DataAreaMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	DataAreaIndex(ctx context.Context, in *DataAreaIndexReq, opts ...grpc.CallOption) (*DataAreaIndexResp, error)
	DataAreaMultiDelete(ctx context.Context, in *DataAreaMultiDeleteReq, opts ...grpc.CallOption) (*Response, error)
	UserAreaApplyIndex(ctx context.Context, in *UserAreaApplyIndexReq, opts ...grpc.CallOption) (*UserAreaApplyIndexResp, error)
	UserAreaApplyDeal(ctx context.Context, in *UserAreaApplyDealReq, opts ...grpc.CallOption) (*Response, error)
}

type dataManageClient struct {
	cc grpc.ClientConnInterface
}

func NewDataManageClient(cc grpc.ClientConnInterface) DataManageClient {
	return &dataManageClient{cc}
}

func (c *dataManageClient) DataProjectMultiUpdate(ctx context.Context, in *DataProjectMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, DataManage_DataProjectMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataManageClient) DataProjectIndex(ctx context.Context, in *DataProjectIndexReq, opts ...grpc.CallOption) (*DataProjectIndexResp, error) {
	out := new(DataProjectIndexResp)
	err := c.cc.Invoke(ctx, DataManage_DataProjectIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataManageClient) DataAreaMultiUpdate(ctx context.Context, in *DataAreaMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, DataManage_DataAreaMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataManageClient) DataAreaIndex(ctx context.Context, in *DataAreaIndexReq, opts ...grpc.CallOption) (*DataAreaIndexResp, error) {
	out := new(DataAreaIndexResp)
	err := c.cc.Invoke(ctx, DataManage_DataAreaIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataManageClient) DataAreaMultiDelete(ctx context.Context, in *DataAreaMultiDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, DataManage_DataAreaMultiDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataManageClient) UserAreaApplyIndex(ctx context.Context, in *UserAreaApplyIndexReq, opts ...grpc.CallOption) (*UserAreaApplyIndexResp, error) {
	out := new(UserAreaApplyIndexResp)
	err := c.cc.Invoke(ctx, DataManage_UserAreaApplyIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataManageClient) UserAreaApplyDeal(ctx context.Context, in *UserAreaApplyDealReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, DataManage_UserAreaApplyDeal_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataManageServer is the server API for DataManage service.
// All implementations must embed UnimplementedDataManageServer
// for forward compatibility
type DataManageServer interface {
	DataProjectMultiUpdate(context.Context, *DataProjectMultiUpdateReq) (*Response, error)
	DataProjectIndex(context.Context, *DataProjectIndexReq) (*DataProjectIndexResp, error)
	DataAreaMultiUpdate(context.Context, *DataAreaMultiUpdateReq) (*Response, error)
	DataAreaIndex(context.Context, *DataAreaIndexReq) (*DataAreaIndexResp, error)
	DataAreaMultiDelete(context.Context, *DataAreaMultiDeleteReq) (*Response, error)
	UserAreaApplyIndex(context.Context, *UserAreaApplyIndexReq) (*UserAreaApplyIndexResp, error)
	UserAreaApplyDeal(context.Context, *UserAreaApplyDealReq) (*Response, error)
	mustEmbedUnimplementedDataManageServer()
}

// UnimplementedDataManageServer must be embedded to have forward compatible implementations.
type UnimplementedDataManageServer struct {
}

func (UnimplementedDataManageServer) DataProjectMultiUpdate(context.Context, *DataProjectMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataProjectMultiUpdate not implemented")
}
func (UnimplementedDataManageServer) DataProjectIndex(context.Context, *DataProjectIndexReq) (*DataProjectIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataProjectIndex not implemented")
}
func (UnimplementedDataManageServer) DataAreaMultiUpdate(context.Context, *DataAreaMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataAreaMultiUpdate not implemented")
}
func (UnimplementedDataManageServer) DataAreaIndex(context.Context, *DataAreaIndexReq) (*DataAreaIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataAreaIndex not implemented")
}
func (UnimplementedDataManageServer) DataAreaMultiDelete(context.Context, *DataAreaMultiDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataAreaMultiDelete not implemented")
}
func (UnimplementedDataManageServer) UserAreaApplyIndex(context.Context, *UserAreaApplyIndexReq) (*UserAreaApplyIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAreaApplyIndex not implemented")
}
func (UnimplementedDataManageServer) UserAreaApplyDeal(context.Context, *UserAreaApplyDealReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAreaApplyDeal not implemented")
}
func (UnimplementedDataManageServer) mustEmbedUnimplementedDataManageServer() {}

// UnsafeDataManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataManageServer will
// result in compilation errors.
type UnsafeDataManageServer interface {
	mustEmbedUnimplementedDataManageServer()
}

func RegisterDataManageServer(s grpc.ServiceRegistrar, srv DataManageServer) {
	s.RegisterService(&DataManage_ServiceDesc, srv)
}

func _DataManage_DataProjectMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataProjectMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).DataProjectMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_DataProjectMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).DataProjectMultiUpdate(ctx, req.(*DataProjectMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataManage_DataProjectIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataProjectIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).DataProjectIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_DataProjectIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).DataProjectIndex(ctx, req.(*DataProjectIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataManage_DataAreaMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataAreaMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).DataAreaMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_DataAreaMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).DataAreaMultiUpdate(ctx, req.(*DataAreaMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataManage_DataAreaIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataAreaIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).DataAreaIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_DataAreaIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).DataAreaIndex(ctx, req.(*DataAreaIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataManage_DataAreaMultiDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataAreaMultiDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).DataAreaMultiDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_DataAreaMultiDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).DataAreaMultiDelete(ctx, req.(*DataAreaMultiDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataManage_UserAreaApplyIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAreaApplyIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).UserAreaApplyIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_UserAreaApplyIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).UserAreaApplyIndex(ctx, req.(*UserAreaApplyIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataManage_UserAreaApplyDeal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAreaApplyDealReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).UserAreaApplyDeal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_UserAreaApplyDeal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).UserAreaApplyDeal(ctx, req.(*UserAreaApplyDealReq))
	}
	return interceptor(ctx, in, info, handler)
}

// DataManage_ServiceDesc is the grpc.ServiceDesc for DataManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.DataManage",
	HandlerType: (*DataManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "dataProjectMultiUpdate",
			Handler:    _DataManage_DataProjectMultiUpdate_Handler,
		},
		{
			MethodName: "dataProjectIndex",
			Handler:    _DataManage_DataProjectIndex_Handler,
		},
		{
			MethodName: "dataAreaMultiUpdate",
			Handler:    _DataManage_DataAreaMultiUpdate_Handler,
		},
		{
			MethodName: "dataAreaIndex",
			Handler:    _DataManage_DataAreaIndex_Handler,
		},
		{
			MethodName: "dataAreaMultiDelete",
			Handler:    _DataManage_DataAreaMultiDelete_Handler,
		},
		{
			MethodName: "userAreaApplyIndex",
			Handler:    _DataManage_UserAreaApplyIndex_Handler,
		},
		{
			MethodName: "userAreaApplyDeal",
			Handler:    _DataManage_UserAreaApplyDeal_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	AccessManage_ApiInfoCreate_FullMethodName    = "/sys.AccessManage/apiInfoCreate"
	AccessManage_ApiInfoIndex_FullMethodName     = "/sys.AccessManage/apiInfoIndex"
	AccessManage_ApiInfoUpdate_FullMethodName    = "/sys.AccessManage/apiInfoUpdate"
	AccessManage_ApiInfoDelete_FullMethodName    = "/sys.AccessManage/apiInfoDelete"
	AccessManage_AccessInfoCreate_FullMethodName = "/sys.AccessManage/accessInfoCreate"
	AccessManage_AccessInfoIndex_FullMethodName  = "/sys.AccessManage/accessInfoIndex"
	AccessManage_AccessInfoUpdate_FullMethodName = "/sys.AccessManage/accessInfoUpdate"
	AccessManage_AccessInfoDelete_FullMethodName = "/sys.AccessManage/accessInfoDelete"
)

// AccessManageClient is the client API for AccessManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccessManageClient interface {
	ApiInfoCreate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*WithID, error)
	ApiInfoIndex(ctx context.Context, in *ApiInfoIndexReq, opts ...grpc.CallOption) (*ApiInfoIndexResp, error)
	ApiInfoUpdate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*Response, error)
	ApiInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error)
	AccessInfoCreate(ctx context.Context, in *AccessInfo, opts ...grpc.CallOption) (*WithID, error)
	AccessInfoIndex(ctx context.Context, in *AccessInfoIndexReq, opts ...grpc.CallOption) (*AccessInfoIndexResp, error)
	AccessInfoUpdate(ctx context.Context, in *AccessInfo, opts ...grpc.CallOption) (*Response, error)
	AccessInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error)
}

type accessManageClient struct {
	cc grpc.ClientConnInterface
}

func NewAccessManageClient(cc grpc.ClientConnInterface) AccessManageClient {
	return &accessManageClient{cc}
}

func (c *accessManageClient) ApiInfoCreate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, AccessManage_ApiInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) ApiInfoIndex(ctx context.Context, in *ApiInfoIndexReq, opts ...grpc.CallOption) (*ApiInfoIndexResp, error) {
	out := new(ApiInfoIndexResp)
	err := c.cc.Invoke(ctx, AccessManage_ApiInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) ApiInfoUpdate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AccessManage_ApiInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) ApiInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AccessManage_ApiInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) AccessInfoCreate(ctx context.Context, in *AccessInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, AccessManage_AccessInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) AccessInfoIndex(ctx context.Context, in *AccessInfoIndexReq, opts ...grpc.CallOption) (*AccessInfoIndexResp, error) {
	out := new(AccessInfoIndexResp)
	err := c.cc.Invoke(ctx, AccessManage_AccessInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) AccessInfoUpdate(ctx context.Context, in *AccessInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AccessManage_AccessInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) AccessInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AccessManage_AccessInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccessManageServer is the server API for AccessManage service.
// All implementations must embed UnimplementedAccessManageServer
// for forward compatibility
type AccessManageServer interface {
	ApiInfoCreate(context.Context, *ApiInfo) (*WithID, error)
	ApiInfoIndex(context.Context, *ApiInfoIndexReq) (*ApiInfoIndexResp, error)
	ApiInfoUpdate(context.Context, *ApiInfo) (*Response, error)
	ApiInfoDelete(context.Context, *WithID) (*Response, error)
	AccessInfoCreate(context.Context, *AccessInfo) (*WithID, error)
	AccessInfoIndex(context.Context, *AccessInfoIndexReq) (*AccessInfoIndexResp, error)
	AccessInfoUpdate(context.Context, *AccessInfo) (*Response, error)
	AccessInfoDelete(context.Context, *WithID) (*Response, error)
	mustEmbedUnimplementedAccessManageServer()
}

// UnimplementedAccessManageServer must be embedded to have forward compatible implementations.
type UnimplementedAccessManageServer struct {
}

func (UnimplementedAccessManageServer) ApiInfoCreate(context.Context, *ApiInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoCreate not implemented")
}
func (UnimplementedAccessManageServer) ApiInfoIndex(context.Context, *ApiInfoIndexReq) (*ApiInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoIndex not implemented")
}
func (UnimplementedAccessManageServer) ApiInfoUpdate(context.Context, *ApiInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoUpdate not implemented")
}
func (UnimplementedAccessManageServer) ApiInfoDelete(context.Context, *WithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoDelete not implemented")
}
func (UnimplementedAccessManageServer) AccessInfoCreate(context.Context, *AccessInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessInfoCreate not implemented")
}
func (UnimplementedAccessManageServer) AccessInfoIndex(context.Context, *AccessInfoIndexReq) (*AccessInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessInfoIndex not implemented")
}
func (UnimplementedAccessManageServer) AccessInfoUpdate(context.Context, *AccessInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessInfoUpdate not implemented")
}
func (UnimplementedAccessManageServer) AccessInfoDelete(context.Context, *WithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessInfoDelete not implemented")
}
func (UnimplementedAccessManageServer) mustEmbedUnimplementedAccessManageServer() {}

// UnsafeAccessManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccessManageServer will
// result in compilation errors.
type UnsafeAccessManageServer interface {
	mustEmbedUnimplementedAccessManageServer()
}

func RegisterAccessManageServer(s grpc.ServiceRegistrar, srv AccessManageServer) {
	s.RegisterService(&AccessManage_ServiceDesc, srv)
}

func _AccessManage_ApiInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).ApiInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_ApiInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).ApiInfoCreate(ctx, req.(*ApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_ApiInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).ApiInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_ApiInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).ApiInfoIndex(ctx, req.(*ApiInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_ApiInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).ApiInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_ApiInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).ApiInfoUpdate(ctx, req.(*ApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_ApiInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).ApiInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_ApiInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).ApiInfoDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_AccessInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).AccessInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_AccessInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).AccessInfoCreate(ctx, req.(*AccessInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_AccessInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).AccessInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_AccessInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).AccessInfoIndex(ctx, req.(*AccessInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_AccessInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).AccessInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_AccessInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).AccessInfoUpdate(ctx, req.(*AccessInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_AccessInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).AccessInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_AccessInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).AccessInfoDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

// AccessManage_ServiceDesc is the grpc.ServiceDesc for AccessManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccessManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.AccessManage",
	HandlerType: (*AccessManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "apiInfoCreate",
			Handler:    _AccessManage_ApiInfoCreate_Handler,
		},
		{
			MethodName: "apiInfoIndex",
			Handler:    _AccessManage_ApiInfoIndex_Handler,
		},
		{
			MethodName: "apiInfoUpdate",
			Handler:    _AccessManage_ApiInfoUpdate_Handler,
		},
		{
			MethodName: "apiInfoDelete",
			Handler:    _AccessManage_ApiInfoDelete_Handler,
		},
		{
			MethodName: "accessInfoCreate",
			Handler:    _AccessManage_AccessInfoCreate_Handler,
		},
		{
			MethodName: "accessInfoIndex",
			Handler:    _AccessManage_AccessInfoIndex_Handler,
		},
		{
			MethodName: "accessInfoUpdate",
			Handler:    _AccessManage_AccessInfoUpdate_Handler,
		},
		{
			MethodName: "accessInfoDelete",
			Handler:    _AccessManage_AccessInfoDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	RoleManage_RoleInfoCreate_FullMethodName        = "/sys.RoleManage/roleInfoCreate"
	RoleManage_RoleInfoIndex_FullMethodName         = "/sys.RoleManage/roleInfoIndex"
	RoleManage_RoleInfoUpdate_FullMethodName        = "/sys.RoleManage/roleInfoUpdate"
	RoleManage_RoleInfoDelete_FullMethodName        = "/sys.RoleManage/roleInfoDelete"
	RoleManage_RoleMenuIndex_FullMethodName         = "/sys.RoleManage/roleMenuIndex"
	RoleManage_RoleMenuMultiUpdate_FullMethodName   = "/sys.RoleManage/roleMenuMultiUpdate"
	RoleManage_RoleAppIndex_FullMethodName          = "/sys.RoleManage/roleAppIndex"
	RoleManage_RoleAppMultiUpdate_FullMethodName    = "/sys.RoleManage/roleAppMultiUpdate"
	RoleManage_RoleModuleIndex_FullMethodName       = "/sys.RoleManage/roleModuleIndex"
	RoleManage_RoleModuleMultiUpdate_FullMethodName = "/sys.RoleManage/roleModuleMultiUpdate"
	RoleManage_RoleApiAuth_FullMethodName           = "/sys.RoleManage/roleApiAuth"
	RoleManage_RoleAccessMultiUpdate_FullMethodName = "/sys.RoleManage/roleAccessMultiUpdate"
	RoleManage_RoleAccessIndex_FullMethodName       = "/sys.RoleManage/roleAccessIndex"
)

// RoleManageClient is the client API for RoleManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleManageClient interface {
	RoleInfoCreate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*WithID, error)
	RoleInfoIndex(ctx context.Context, in *RoleInfoIndexReq, opts ...grpc.CallOption) (*RoleInfoIndexResp, error)
	RoleInfoUpdate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*Response, error)
	RoleInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error)
	RoleMenuIndex(ctx context.Context, in *RoleMenuIndexReq, opts ...grpc.CallOption) (*RoleMenuIndexResp, error)
	RoleMenuMultiUpdate(ctx context.Context, in *RoleMenuMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleAppIndex(ctx context.Context, in *RoleAppIndexReq, opts ...grpc.CallOption) (*RoleAppIndexResp, error)
	RoleAppMultiUpdate(ctx context.Context, in *RoleAppMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleModuleIndex(ctx context.Context, in *RoleModuleIndexReq, opts ...grpc.CallOption) (*RoleModuleIndexResp, error)
	RoleModuleMultiUpdate(ctx context.Context, in *RoleModuleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiAuth(ctx context.Context, in *RoleApiAuthReq, opts ...grpc.CallOption) (*Response, error)
	RoleAccessMultiUpdate(ctx context.Context, in *RoleAccessMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleAccessIndex(ctx context.Context, in *RoleAccessIndexReq, opts ...grpc.CallOption) (*RoleAccessIndexResp, error)
}

type roleManageClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleManageClient(cc grpc.ClientConnInterface) RoleManageClient {
	return &roleManageClient{cc}
}

func (c *roleManageClient) RoleInfoCreate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleInfoIndex(ctx context.Context, in *RoleInfoIndexReq, opts ...grpc.CallOption) (*RoleInfoIndexResp, error) {
	out := new(RoleInfoIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleInfoUpdate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleMenuIndex(ctx context.Context, in *RoleMenuIndexReq, opts ...grpc.CallOption) (*RoleMenuIndexResp, error) {
	out := new(RoleMenuIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleMenuIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleMenuMultiUpdate(ctx context.Context, in *RoleMenuMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleMenuMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleAppIndex(ctx context.Context, in *RoleAppIndexReq, opts ...grpc.CallOption) (*RoleAppIndexResp, error) {
	out := new(RoleAppIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleAppIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleAppMultiUpdate(ctx context.Context, in *RoleAppMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleAppMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleModuleIndex(ctx context.Context, in *RoleModuleIndexReq, opts ...grpc.CallOption) (*RoleModuleIndexResp, error) {
	out := new(RoleModuleIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleModuleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleModuleMultiUpdate(ctx context.Context, in *RoleModuleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleModuleMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleApiAuth(ctx context.Context, in *RoleApiAuthReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleApiAuth_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleAccessMultiUpdate(ctx context.Context, in *RoleAccessMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleAccessMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleAccessIndex(ctx context.Context, in *RoleAccessIndexReq, opts ...grpc.CallOption) (*RoleAccessIndexResp, error) {
	out := new(RoleAccessIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleAccessIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleManageServer is the server API for RoleManage service.
// All implementations must embed UnimplementedRoleManageServer
// for forward compatibility
type RoleManageServer interface {
	RoleInfoCreate(context.Context, *RoleInfo) (*WithID, error)
	RoleInfoIndex(context.Context, *RoleInfoIndexReq) (*RoleInfoIndexResp, error)
	RoleInfoUpdate(context.Context, *RoleInfo) (*Response, error)
	RoleInfoDelete(context.Context, *WithID) (*Response, error)
	RoleMenuIndex(context.Context, *RoleMenuIndexReq) (*RoleMenuIndexResp, error)
	RoleMenuMultiUpdate(context.Context, *RoleMenuMultiUpdateReq) (*Response, error)
	RoleAppIndex(context.Context, *RoleAppIndexReq) (*RoleAppIndexResp, error)
	RoleAppMultiUpdate(context.Context, *RoleAppMultiUpdateReq) (*Response, error)
	RoleModuleIndex(context.Context, *RoleModuleIndexReq) (*RoleModuleIndexResp, error)
	RoleModuleMultiUpdate(context.Context, *RoleModuleMultiUpdateReq) (*Response, error)
	RoleApiAuth(context.Context, *RoleApiAuthReq) (*Response, error)
	RoleAccessMultiUpdate(context.Context, *RoleAccessMultiUpdateReq) (*Response, error)
	RoleAccessIndex(context.Context, *RoleAccessIndexReq) (*RoleAccessIndexResp, error)
	mustEmbedUnimplementedRoleManageServer()
}

// UnimplementedRoleManageServer must be embedded to have forward compatible implementations.
type UnimplementedRoleManageServer struct {
}

func (UnimplementedRoleManageServer) RoleInfoCreate(context.Context, *RoleInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoCreate not implemented")
}
func (UnimplementedRoleManageServer) RoleInfoIndex(context.Context, *RoleInfoIndexReq) (*RoleInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleInfoUpdate(context.Context, *RoleInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleInfoDelete(context.Context, *WithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoDelete not implemented")
}
func (UnimplementedRoleManageServer) RoleMenuIndex(context.Context, *RoleMenuIndexReq) (*RoleMenuIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleMenuIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleMenuMultiUpdate(context.Context, *RoleMenuMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleMenuMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleAppIndex(context.Context, *RoleAppIndexReq) (*RoleAppIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAppIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleAppMultiUpdate(context.Context, *RoleAppMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAppMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleModuleIndex(context.Context, *RoleModuleIndexReq) (*RoleModuleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleModuleIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleModuleMultiUpdate(context.Context, *RoleModuleMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleModuleMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleApiAuth(context.Context, *RoleApiAuthReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiAuth not implemented")
}
func (UnimplementedRoleManageServer) RoleAccessMultiUpdate(context.Context, *RoleAccessMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAccessMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleAccessIndex(context.Context, *RoleAccessIndexReq) (*RoleAccessIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAccessIndex not implemented")
}
func (UnimplementedRoleManageServer) mustEmbedUnimplementedRoleManageServer() {}

// UnsafeRoleManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleManageServer will
// result in compilation errors.
type UnsafeRoleManageServer interface {
	mustEmbedUnimplementedRoleManageServer()
}

func RegisterRoleManageServer(s grpc.ServiceRegistrar, srv RoleManageServer) {
	s.RegisterService(&RoleManage_ServiceDesc, srv)
}

func _RoleManage_RoleInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoCreate(ctx, req.(*RoleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoIndex(ctx, req.(*RoleInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoUpdate(ctx, req.(*RoleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleMenuIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMenuIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleMenuIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleMenuIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleMenuIndex(ctx, req.(*RoleMenuIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleMenuMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMenuMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleMenuMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleMenuMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleMenuMultiUpdate(ctx, req.(*RoleMenuMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleAppIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAppIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleAppIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleAppIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleAppIndex(ctx, req.(*RoleAppIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleAppMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAppMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleAppMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleAppMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleAppMultiUpdate(ctx, req.(*RoleAppMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleModuleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleModuleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleModuleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleModuleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleModuleIndex(ctx, req.(*RoleModuleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleModuleMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleModuleMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleModuleMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleModuleMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleModuleMultiUpdate(ctx, req.(*RoleModuleMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleApiAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiAuthReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleApiAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleApiAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleApiAuth(ctx, req.(*RoleApiAuthReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleAccessMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAccessMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleAccessMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleAccessMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleAccessMultiUpdate(ctx, req.(*RoleAccessMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleAccessIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAccessIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleAccessIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleAccessIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleAccessIndex(ctx, req.(*RoleAccessIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// RoleManage_ServiceDesc is the grpc.ServiceDesc for RoleManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoleManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.RoleManage",
	HandlerType: (*RoleManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "roleInfoCreate",
			Handler:    _RoleManage_RoleInfoCreate_Handler,
		},
		{
			MethodName: "roleInfoIndex",
			Handler:    _RoleManage_RoleInfoIndex_Handler,
		},
		{
			MethodName: "roleInfoUpdate",
			Handler:    _RoleManage_RoleInfoUpdate_Handler,
		},
		{
			MethodName: "roleInfoDelete",
			Handler:    _RoleManage_RoleInfoDelete_Handler,
		},
		{
			MethodName: "roleMenuIndex",
			Handler:    _RoleManage_RoleMenuIndex_Handler,
		},
		{
			MethodName: "roleMenuMultiUpdate",
			Handler:    _RoleManage_RoleMenuMultiUpdate_Handler,
		},
		{
			MethodName: "roleAppIndex",
			Handler:    _RoleManage_RoleAppIndex_Handler,
		},
		{
			MethodName: "roleAppMultiUpdate",
			Handler:    _RoleManage_RoleAppMultiUpdate_Handler,
		},
		{
			MethodName: "roleModuleIndex",
			Handler:    _RoleManage_RoleModuleIndex_Handler,
		},
		{
			MethodName: "roleModuleMultiUpdate",
			Handler:    _RoleManage_RoleModuleMultiUpdate_Handler,
		},
		{
			MethodName: "roleApiAuth",
			Handler:    _RoleManage_RoleApiAuth_Handler,
		},
		{
			MethodName: "roleAccessMultiUpdate",
			Handler:    _RoleManage_RoleAccessMultiUpdate_Handler,
		},
		{
			MethodName: "roleAccessIndex",
			Handler:    _RoleManage_RoleAccessIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	AppManage_AppInfoCreate_FullMethodName        = "/sys.AppManage/appInfoCreate"
	AppManage_AppInfoIndex_FullMethodName         = "/sys.AppManage/appInfoIndex"
	AppManage_AppInfoUpdate_FullMethodName        = "/sys.AppManage/appInfoUpdate"
	AppManage_AppInfoDelete_FullMethodName        = "/sys.AppManage/appInfoDelete"
	AppManage_AppInfoRead_FullMethodName          = "/sys.AppManage/appInfoRead"
	AppManage_AppModuleIndex_FullMethodName       = "/sys.AppManage/appModuleIndex"
	AppManage_AppModuleMultiUpdate_FullMethodName = "/sys.AppManage/appModuleMultiUpdate"
)

// AppManageClient is the client API for AppManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AppManageClient interface {
	AppInfoCreate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*WithID, error)
	AppInfoIndex(ctx context.Context, in *AppInfoIndexReq, opts ...grpc.CallOption) (*AppInfoIndexResp, error)
	AppInfoUpdate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*Response, error)
	AppInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Response, error)
	AppInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*AppInfo, error)
	AppModuleIndex(ctx context.Context, in *AppModuleIndexReq, opts ...grpc.CallOption) (*AppModuleIndexResp, error)
	AppModuleMultiUpdate(ctx context.Context, in *AppModuleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
}

type appManageClient struct {
	cc grpc.ClientConnInterface
}

func NewAppManageClient(cc grpc.ClientConnInterface) AppManageClient {
	return &appManageClient{cc}
}

func (c *appManageClient) AppInfoCreate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, AppManage_AppInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoIndex(ctx context.Context, in *AppInfoIndexReq, opts ...grpc.CallOption) (*AppInfoIndexResp, error) {
	out := new(AppInfoIndexResp)
	err := c.cc.Invoke(ctx, AppManage_AppInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoUpdate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AppManage_AppInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AppManage_AppInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*AppInfo, error) {
	out := new(AppInfo)
	err := c.cc.Invoke(ctx, AppManage_AppInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppModuleIndex(ctx context.Context, in *AppModuleIndexReq, opts ...grpc.CallOption) (*AppModuleIndexResp, error) {
	out := new(AppModuleIndexResp)
	err := c.cc.Invoke(ctx, AppManage_AppModuleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppModuleMultiUpdate(ctx context.Context, in *AppModuleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AppManage_AppModuleMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppManageServer is the server API for AppManage service.
// All implementations must embed UnimplementedAppManageServer
// for forward compatibility
type AppManageServer interface {
	AppInfoCreate(context.Context, *AppInfo) (*WithID, error)
	AppInfoIndex(context.Context, *AppInfoIndexReq) (*AppInfoIndexResp, error)
	AppInfoUpdate(context.Context, *AppInfo) (*Response, error)
	AppInfoDelete(context.Context, *WithIDCode) (*Response, error)
	AppInfoRead(context.Context, *WithIDCode) (*AppInfo, error)
	AppModuleIndex(context.Context, *AppModuleIndexReq) (*AppModuleIndexResp, error)
	AppModuleMultiUpdate(context.Context, *AppModuleMultiUpdateReq) (*Response, error)
	mustEmbedUnimplementedAppManageServer()
}

// UnimplementedAppManageServer must be embedded to have forward compatible implementations.
type UnimplementedAppManageServer struct {
}

func (UnimplementedAppManageServer) AppInfoCreate(context.Context, *AppInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoCreate not implemented")
}
func (UnimplementedAppManageServer) AppInfoIndex(context.Context, *AppInfoIndexReq) (*AppInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoIndex not implemented")
}
func (UnimplementedAppManageServer) AppInfoUpdate(context.Context, *AppInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoUpdate not implemented")
}
func (UnimplementedAppManageServer) AppInfoDelete(context.Context, *WithIDCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoDelete not implemented")
}
func (UnimplementedAppManageServer) AppInfoRead(context.Context, *WithIDCode) (*AppInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoRead not implemented")
}
func (UnimplementedAppManageServer) AppModuleIndex(context.Context, *AppModuleIndexReq) (*AppModuleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppModuleIndex not implemented")
}
func (UnimplementedAppManageServer) AppModuleMultiUpdate(context.Context, *AppModuleMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppModuleMultiUpdate not implemented")
}
func (UnimplementedAppManageServer) mustEmbedUnimplementedAppManageServer() {}

// UnsafeAppManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AppManageServer will
// result in compilation errors.
type UnsafeAppManageServer interface {
	mustEmbedUnimplementedAppManageServer()
}

func RegisterAppManageServer(s grpc.ServiceRegistrar, srv AppManageServer) {
	s.RegisterService(&AppManage_ServiceDesc, srv)
}

func _AppManage_AppInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoCreate(ctx, req.(*AppInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoIndex(ctx, req.(*AppInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoUpdate(ctx, req.(*AppInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoDelete(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoRead(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppModuleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppModuleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppModuleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppModuleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppModuleIndex(ctx, req.(*AppModuleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppModuleMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppModuleMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppModuleMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppModuleMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppModuleMultiUpdate(ctx, req.(*AppModuleMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AppManage_ServiceDesc is the grpc.ServiceDesc for AppManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AppManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.AppManage",
	HandlerType: (*AppManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "appInfoCreate",
			Handler:    _AppManage_AppInfoCreate_Handler,
		},
		{
			MethodName: "appInfoIndex",
			Handler:    _AppManage_AppInfoIndex_Handler,
		},
		{
			MethodName: "appInfoUpdate",
			Handler:    _AppManage_AppInfoUpdate_Handler,
		},
		{
			MethodName: "appInfoDelete",
			Handler:    _AppManage_AppInfoDelete_Handler,
		},
		{
			MethodName: "appInfoRead",
			Handler:    _AppManage_AppInfoRead_Handler,
		},
		{
			MethodName: "appModuleIndex",
			Handler:    _AppManage_AppModuleIndex_Handler,
		},
		{
			MethodName: "appModuleMultiUpdate",
			Handler:    _AppManage_AppModuleMultiUpdate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	ModuleManage_ModuleInfoCreate_FullMethodName = "/sys.ModuleManage/moduleInfoCreate"
	ModuleManage_ModuleInfoIndex_FullMethodName  = "/sys.ModuleManage/moduleInfoIndex"
	ModuleManage_ModuleInfoUpdate_FullMethodName = "/sys.ModuleManage/moduleInfoUpdate"
	ModuleManage_ModuleInfoDelete_FullMethodName = "/sys.ModuleManage/moduleInfoDelete"
	ModuleManage_ModuleInfoRead_FullMethodName   = "/sys.ModuleManage/moduleInfoRead"
	ModuleManage_ModuleMenuCreate_FullMethodName = "/sys.ModuleManage/moduleMenuCreate"
	ModuleManage_ModuleMenuIndex_FullMethodName  = "/sys.ModuleManage/moduleMenuIndex"
	ModuleManage_ModuleMenuUpdate_FullMethodName = "/sys.ModuleManage/moduleMenuUpdate"
	ModuleManage_ModuleMenuDelete_FullMethodName = "/sys.ModuleManage/moduleMenuDelete"
)

// ModuleManageClient is the client API for ModuleManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ModuleManageClient interface {
	ModuleInfoCreate(ctx context.Context, in *ModuleInfo, opts ...grpc.CallOption) (*WithID, error)
	ModuleInfoIndex(ctx context.Context, in *ModuleInfoIndexReq, opts ...grpc.CallOption) (*ModuleInfoIndexResp, error)
	ModuleInfoUpdate(ctx context.Context, in *ModuleInfo, opts ...grpc.CallOption) (*Response, error)
	ModuleInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Response, error)
	ModuleInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*ModuleInfo, error)
	ModuleMenuCreate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*WithID, error)
	ModuleMenuIndex(ctx context.Context, in *MenuInfoIndexReq, opts ...grpc.CallOption) (*MenuInfoIndexResp, error)
	ModuleMenuUpdate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*Response, error)
	ModuleMenuDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error)
}

type moduleManageClient struct {
	cc grpc.ClientConnInterface
}

func NewModuleManageClient(cc grpc.ClientConnInterface) ModuleManageClient {
	return &moduleManageClient{cc}
}

func (c *moduleManageClient) ModuleInfoCreate(ctx context.Context, in *ModuleInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleInfoIndex(ctx context.Context, in *ModuleInfoIndexReq, opts ...grpc.CallOption) (*ModuleInfoIndexResp, error) {
	out := new(ModuleInfoIndexResp)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleInfoUpdate(ctx context.Context, in *ModuleInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*ModuleInfo, error) {
	out := new(ModuleInfo)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleMenuCreate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleMenuCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleMenuIndex(ctx context.Context, in *MenuInfoIndexReq, opts ...grpc.CallOption) (*MenuInfoIndexResp, error) {
	out := new(MenuInfoIndexResp)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleMenuIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleMenuUpdate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleMenuUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleMenuDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleMenuDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ModuleManageServer is the server API for ModuleManage service.
// All implementations must embed UnimplementedModuleManageServer
// for forward compatibility
type ModuleManageServer interface {
	ModuleInfoCreate(context.Context, *ModuleInfo) (*WithID, error)
	ModuleInfoIndex(context.Context, *ModuleInfoIndexReq) (*ModuleInfoIndexResp, error)
	ModuleInfoUpdate(context.Context, *ModuleInfo) (*Response, error)
	ModuleInfoDelete(context.Context, *WithIDCode) (*Response, error)
	ModuleInfoRead(context.Context, *WithIDCode) (*ModuleInfo, error)
	ModuleMenuCreate(context.Context, *MenuInfo) (*WithID, error)
	ModuleMenuIndex(context.Context, *MenuInfoIndexReq) (*MenuInfoIndexResp, error)
	ModuleMenuUpdate(context.Context, *MenuInfo) (*Response, error)
	ModuleMenuDelete(context.Context, *WithID) (*Response, error)
	mustEmbedUnimplementedModuleManageServer()
}

// UnimplementedModuleManageServer must be embedded to have forward compatible implementations.
type UnimplementedModuleManageServer struct {
}

func (UnimplementedModuleManageServer) ModuleInfoCreate(context.Context, *ModuleInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoCreate not implemented")
}
func (UnimplementedModuleManageServer) ModuleInfoIndex(context.Context, *ModuleInfoIndexReq) (*ModuleInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoIndex not implemented")
}
func (UnimplementedModuleManageServer) ModuleInfoUpdate(context.Context, *ModuleInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoUpdate not implemented")
}
func (UnimplementedModuleManageServer) ModuleInfoDelete(context.Context, *WithIDCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoDelete not implemented")
}
func (UnimplementedModuleManageServer) ModuleInfoRead(context.Context, *WithIDCode) (*ModuleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoRead not implemented")
}
func (UnimplementedModuleManageServer) ModuleMenuCreate(context.Context, *MenuInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleMenuCreate not implemented")
}
func (UnimplementedModuleManageServer) ModuleMenuIndex(context.Context, *MenuInfoIndexReq) (*MenuInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleMenuIndex not implemented")
}
func (UnimplementedModuleManageServer) ModuleMenuUpdate(context.Context, *MenuInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleMenuUpdate not implemented")
}
func (UnimplementedModuleManageServer) ModuleMenuDelete(context.Context, *WithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleMenuDelete not implemented")
}
func (UnimplementedModuleManageServer) mustEmbedUnimplementedModuleManageServer() {}

// UnsafeModuleManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ModuleManageServer will
// result in compilation errors.
type UnsafeModuleManageServer interface {
	mustEmbedUnimplementedModuleManageServer()
}

func RegisterModuleManageServer(s grpc.ServiceRegistrar, srv ModuleManageServer) {
	s.RegisterService(&ModuleManage_ServiceDesc, srv)
}

func _ModuleManage_ModuleInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoCreate(ctx, req.(*ModuleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoIndex(ctx, req.(*ModuleInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoUpdate(ctx, req.(*ModuleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoDelete(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoRead(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleMenuCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleMenuCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleMenuCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleMenuCreate(ctx, req.(*MenuInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleMenuIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleMenuIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleMenuIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleMenuIndex(ctx, req.(*MenuInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleMenuUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleMenuUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleMenuUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleMenuUpdate(ctx, req.(*MenuInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleMenuDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleMenuDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleMenuDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleMenuDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

// ModuleManage_ServiceDesc is the grpc.ServiceDesc for ModuleManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ModuleManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.ModuleManage",
	HandlerType: (*ModuleManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "moduleInfoCreate",
			Handler:    _ModuleManage_ModuleInfoCreate_Handler,
		},
		{
			MethodName: "moduleInfoIndex",
			Handler:    _ModuleManage_ModuleInfoIndex_Handler,
		},
		{
			MethodName: "moduleInfoUpdate",
			Handler:    _ModuleManage_ModuleInfoUpdate_Handler,
		},
		{
			MethodName: "moduleInfoDelete",
			Handler:    _ModuleManage_ModuleInfoDelete_Handler,
		},
		{
			MethodName: "moduleInfoRead",
			Handler:    _ModuleManage_ModuleInfoRead_Handler,
		},
		{
			MethodName: "moduleMenuCreate",
			Handler:    _ModuleManage_ModuleMenuCreate_Handler,
		},
		{
			MethodName: "moduleMenuIndex",
			Handler:    _ModuleManage_ModuleMenuIndex_Handler,
		},
		{
			MethodName: "moduleMenuUpdate",
			Handler:    _ModuleManage_ModuleMenuUpdate_Handler,
		},
		{
			MethodName: "moduleMenuDelete",
			Handler:    _ModuleManage_ModuleMenuDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Common_Config_FullMethodName = "/sys.Common/config"
)

// CommonClient is the client API for Common service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommonClient interface {
	Config(ctx context.Context, in *Response, opts ...grpc.CallOption) (*ConfigResp, error)
}

type commonClient struct {
	cc grpc.ClientConnInterface
}

func NewCommonClient(cc grpc.ClientConnInterface) CommonClient {
	return &commonClient{cc}
}

func (c *commonClient) Config(ctx context.Context, in *Response, opts ...grpc.CallOption) (*ConfigResp, error) {
	out := new(ConfigResp)
	err := c.cc.Invoke(ctx, Common_Config_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommonServer is the server API for Common service.
// All implementations must embed UnimplementedCommonServer
// for forward compatibility
type CommonServer interface {
	Config(context.Context, *Response) (*ConfigResp, error)
	mustEmbedUnimplementedCommonServer()
}

// UnimplementedCommonServer must be embedded to have forward compatible implementations.
type UnimplementedCommonServer struct {
}

func (UnimplementedCommonServer) Config(context.Context, *Response) (*ConfigResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Config not implemented")
}
func (UnimplementedCommonServer) mustEmbedUnimplementedCommonServer() {}

// UnsafeCommonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommonServer will
// result in compilation errors.
type UnsafeCommonServer interface {
	mustEmbedUnimplementedCommonServer()
}

func RegisterCommonServer(s grpc.ServiceRegistrar, srv CommonServer) {
	s.RegisterService(&Common_ServiceDesc, srv)
}

func _Common_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonServer).Config(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Common_Config_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonServer).Config(ctx, req.(*Response))
	}
	return interceptor(ctx, in, info, handler)
}

// Common_ServiceDesc is the grpc.ServiceDesc for Common service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Common_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Common",
	HandlerType: (*CommonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "config",
			Handler:    _Common_Config_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Log_LoginLogIndex_FullMethodName  = "/sys.Log/loginLogIndex"
	Log_OperLogIndex_FullMethodName   = "/sys.Log/operLogIndex"
	Log_LoginLogCreate_FullMethodName = "/sys.Log/loginLogCreate"
	Log_OperLogCreate_FullMethodName  = "/sys.Log/operLogCreate"
)

// LogClient is the client API for Log service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogClient interface {
	LoginLogIndex(ctx context.Context, in *LoginLogIndexReq, opts ...grpc.CallOption) (*LoginLogIndexResp, error)
	OperLogIndex(ctx context.Context, in *OperLogIndexReq, opts ...grpc.CallOption) (*OperLogIndexResp, error)
	LoginLogCreate(ctx context.Context, in *LoginLogCreateReq, opts ...grpc.CallOption) (*Response, error)
	OperLogCreate(ctx context.Context, in *OperLogCreateReq, opts ...grpc.CallOption) (*Response, error)
}

type logClient struct {
	cc grpc.ClientConnInterface
}

func NewLogClient(cc grpc.ClientConnInterface) LogClient {
	return &logClient{cc}
}

func (c *logClient) LoginLogIndex(ctx context.Context, in *LoginLogIndexReq, opts ...grpc.CallOption) (*LoginLogIndexResp, error) {
	out := new(LoginLogIndexResp)
	err := c.cc.Invoke(ctx, Log_LoginLogIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) OperLogIndex(ctx context.Context, in *OperLogIndexReq, opts ...grpc.CallOption) (*OperLogIndexResp, error) {
	out := new(OperLogIndexResp)
	err := c.cc.Invoke(ctx, Log_OperLogIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) LoginLogCreate(ctx context.Context, in *LoginLogCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Log_LoginLogCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) OperLogCreate(ctx context.Context, in *OperLogCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Log_OperLogCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LogServer is the server API for Log service.
// All implementations must embed UnimplementedLogServer
// for forward compatibility
type LogServer interface {
	LoginLogIndex(context.Context, *LoginLogIndexReq) (*LoginLogIndexResp, error)
	OperLogIndex(context.Context, *OperLogIndexReq) (*OperLogIndexResp, error)
	LoginLogCreate(context.Context, *LoginLogCreateReq) (*Response, error)
	OperLogCreate(context.Context, *OperLogCreateReq) (*Response, error)
	mustEmbedUnimplementedLogServer()
}

// UnimplementedLogServer must be embedded to have forward compatible implementations.
type UnimplementedLogServer struct {
}

func (UnimplementedLogServer) LoginLogIndex(context.Context, *LoginLogIndexReq) (*LoginLogIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginLogIndex not implemented")
}
func (UnimplementedLogServer) OperLogIndex(context.Context, *OperLogIndexReq) (*OperLogIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperLogIndex not implemented")
}
func (UnimplementedLogServer) LoginLogCreate(context.Context, *LoginLogCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginLogCreate not implemented")
}
func (UnimplementedLogServer) OperLogCreate(context.Context, *OperLogCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperLogCreate not implemented")
}
func (UnimplementedLogServer) mustEmbedUnimplementedLogServer() {}

// UnsafeLogServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogServer will
// result in compilation errors.
type UnsafeLogServer interface {
	mustEmbedUnimplementedLogServer()
}

func RegisterLogServer(s grpc.ServiceRegistrar, srv LogServer) {
	s.RegisterService(&Log_ServiceDesc, srv)
}

func _Log_LoginLogIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginLogIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).LoginLogIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_LoginLogIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).LoginLogIndex(ctx, req.(*LoginLogIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_OperLogIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperLogIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).OperLogIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_OperLogIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).OperLogIndex(ctx, req.(*OperLogIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_LoginLogCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginLogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).LoginLogCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_LoginLogCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).LoginLogCreate(ctx, req.(*LoginLogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_OperLogCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperLogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).OperLogCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_OperLogCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).OperLogCreate(ctx, req.(*OperLogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Log_ServiceDesc is the grpc.ServiceDesc for Log service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Log_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Log",
	HandlerType: (*LogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "loginLogIndex",
			Handler:    _Log_LoginLogIndex_Handler,
		},
		{
			MethodName: "operLogIndex",
			Handler:    _Log_OperLogIndex_Handler,
		},
		{
			MethodName: "loginLogCreate",
			Handler:    _Log_LoginLogCreate_Handler,
		},
		{
			MethodName: "operLogCreate",
			Handler:    _Log_OperLogCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	ProjectManage_ProjectInfoCreate_FullMethodName = "/sys.ProjectManage/projectInfoCreate"
	ProjectManage_ProjectInfoUpdate_FullMethodName = "/sys.ProjectManage/projectInfoUpdate"
	ProjectManage_ProjectInfoDelete_FullMethodName = "/sys.ProjectManage/projectInfoDelete"
	ProjectManage_ProjectInfoRead_FullMethodName   = "/sys.ProjectManage/projectInfoRead"
	ProjectManage_ProjectInfoIndex_FullMethodName  = "/sys.ProjectManage/projectInfoIndex"
)

// ProjectManageClient is the client API for ProjectManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectManageClient interface {
	// 新增项目
	ProjectInfoCreate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*ProjectWithID, error)
	// 更新项目
	ProjectInfoUpdate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Response, error)
	// 删除项目
	ProjectInfoDelete(ctx context.Context, in *ProjectWithID, opts ...grpc.CallOption) (*Response, error)
	// 获取项目信息详情
	ProjectInfoRead(ctx context.Context, in *ProjectWithID, opts ...grpc.CallOption) (*ProjectInfo, error)
	// 获取项目信息列表
	ProjectInfoIndex(ctx context.Context, in *ProjectInfoIndexReq, opts ...grpc.CallOption) (*ProjectInfoIndexResp, error)
}

type projectManageClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectManageClient(cc grpc.ClientConnInterface) ProjectManageClient {
	return &projectManageClient{cc}
}

func (c *projectManageClient) ProjectInfoCreate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*ProjectWithID, error) {
	out := new(ProjectWithID)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoUpdate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoDelete(ctx context.Context, in *ProjectWithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoRead(ctx context.Context, in *ProjectWithID, opts ...grpc.CallOption) (*ProjectInfo, error) {
	out := new(ProjectInfo)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoIndex(ctx context.Context, in *ProjectInfoIndexReq, opts ...grpc.CallOption) (*ProjectInfoIndexResp, error) {
	out := new(ProjectInfoIndexResp)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectManageServer is the server API for ProjectManage service.
// All implementations must embed UnimplementedProjectManageServer
// for forward compatibility
type ProjectManageServer interface {
	// 新增项目
	ProjectInfoCreate(context.Context, *ProjectInfo) (*ProjectWithID, error)
	// 更新项目
	ProjectInfoUpdate(context.Context, *ProjectInfo) (*Response, error)
	// 删除项目
	ProjectInfoDelete(context.Context, *ProjectWithID) (*Response, error)
	// 获取项目信息详情
	ProjectInfoRead(context.Context, *ProjectWithID) (*ProjectInfo, error)
	// 获取项目信息列表
	ProjectInfoIndex(context.Context, *ProjectInfoIndexReq) (*ProjectInfoIndexResp, error)
	mustEmbedUnimplementedProjectManageServer()
}

// UnimplementedProjectManageServer must be embedded to have forward compatible implementations.
type UnimplementedProjectManageServer struct {
}

func (UnimplementedProjectManageServer) ProjectInfoCreate(context.Context, *ProjectInfo) (*ProjectWithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoCreate not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoUpdate(context.Context, *ProjectInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoUpdate not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoDelete(context.Context, *ProjectWithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoDelete not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoRead(context.Context, *ProjectWithID) (*ProjectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoRead not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoIndex(context.Context, *ProjectInfoIndexReq) (*ProjectInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoIndex not implemented")
}
func (UnimplementedProjectManageServer) mustEmbedUnimplementedProjectManageServer() {}

// UnsafeProjectManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectManageServer will
// result in compilation errors.
type UnsafeProjectManageServer interface {
	mustEmbedUnimplementedProjectManageServer()
}

func RegisterProjectManageServer(s grpc.ServiceRegistrar, srv ProjectManageServer) {
	s.RegisterService(&ProjectManage_ServiceDesc, srv)
}

func _ProjectManage_ProjectInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoCreate(ctx, req.(*ProjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoUpdate(ctx, req.(*ProjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoDelete(ctx, req.(*ProjectWithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoRead(ctx, req.(*ProjectWithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoIndex(ctx, req.(*ProjectInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ProjectManage_ServiceDesc is the grpc.ServiceDesc for ProjectManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProjectManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.ProjectManage",
	HandlerType: (*ProjectManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "projectInfoCreate",
			Handler:    _ProjectManage_ProjectInfoCreate_Handler,
		},
		{
			MethodName: "projectInfoUpdate",
			Handler:    _ProjectManage_ProjectInfoUpdate_Handler,
		},
		{
			MethodName: "projectInfoDelete",
			Handler:    _ProjectManage_ProjectInfoDelete_Handler,
		},
		{
			MethodName: "projectInfoRead",
			Handler:    _ProjectManage_ProjectInfoRead_Handler,
		},
		{
			MethodName: "projectInfoIndex",
			Handler:    _ProjectManage_ProjectInfoIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	AreaManage_AreaInfoCreate_FullMethodName = "/sys.AreaManage/areaInfoCreate"
	AreaManage_AreaInfoUpdate_FullMethodName = "/sys.AreaManage/areaInfoUpdate"
	AreaManage_AreaInfoDelete_FullMethodName = "/sys.AreaManage/areaInfoDelete"
	AreaManage_AreaInfoRead_FullMethodName   = "/sys.AreaManage/areaInfoRead"
	AreaManage_AreaInfoIndex_FullMethodName  = "/sys.AreaManage/areaInfoIndex"
)

// AreaManageClient is the client API for AreaManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AreaManageClient interface {
	// 新增区域
	AreaInfoCreate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*AreaWithID, error)
	// 更新区域
	AreaInfoUpdate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Response, error)
	// 删除区域
	AreaInfoDelete(ctx context.Context, in *AreaWithID, opts ...grpc.CallOption) (*Response, error)
	// 获取区域信息详情
	AreaInfoRead(ctx context.Context, in *AreaInfoReadReq, opts ...grpc.CallOption) (*AreaInfo, error)
	// 获取区域信息列表
	AreaInfoIndex(ctx context.Context, in *AreaInfoIndexReq, opts ...grpc.CallOption) (*AreaInfoIndexResp, error)
}

type areaManageClient struct {
	cc grpc.ClientConnInterface
}

func NewAreaManageClient(cc grpc.ClientConnInterface) AreaManageClient {
	return &areaManageClient{cc}
}

func (c *areaManageClient) AreaInfoCreate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*AreaWithID, error) {
	out := new(AreaWithID)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoUpdate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoDelete(ctx context.Context, in *AreaWithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoRead(ctx context.Context, in *AreaInfoReadReq, opts ...grpc.CallOption) (*AreaInfo, error) {
	out := new(AreaInfo)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoIndex(ctx context.Context, in *AreaInfoIndexReq, opts ...grpc.CallOption) (*AreaInfoIndexResp, error) {
	out := new(AreaInfoIndexResp)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AreaManageServer is the server API for AreaManage service.
// All implementations must embed UnimplementedAreaManageServer
// for forward compatibility
type AreaManageServer interface {
	// 新增区域
	AreaInfoCreate(context.Context, *AreaInfo) (*AreaWithID, error)
	// 更新区域
	AreaInfoUpdate(context.Context, *AreaInfo) (*Response, error)
	// 删除区域
	AreaInfoDelete(context.Context, *AreaWithID) (*Response, error)
	// 获取区域信息详情
	AreaInfoRead(context.Context, *AreaInfoReadReq) (*AreaInfo, error)
	// 获取区域信息列表
	AreaInfoIndex(context.Context, *AreaInfoIndexReq) (*AreaInfoIndexResp, error)
	mustEmbedUnimplementedAreaManageServer()
}

// UnimplementedAreaManageServer must be embedded to have forward compatible implementations.
type UnimplementedAreaManageServer struct {
}

func (UnimplementedAreaManageServer) AreaInfoCreate(context.Context, *AreaInfo) (*AreaWithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoCreate not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoUpdate(context.Context, *AreaInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoUpdate not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoDelete(context.Context, *AreaWithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoDelete not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoRead(context.Context, *AreaInfoReadReq) (*AreaInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoRead not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoIndex(context.Context, *AreaInfoIndexReq) (*AreaInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoIndex not implemented")
}
func (UnimplementedAreaManageServer) mustEmbedUnimplementedAreaManageServer() {}

// UnsafeAreaManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AreaManageServer will
// result in compilation errors.
type UnsafeAreaManageServer interface {
	mustEmbedUnimplementedAreaManageServer()
}

func RegisterAreaManageServer(s grpc.ServiceRegistrar, srv AreaManageServer) {
	s.RegisterService(&AreaManage_ServiceDesc, srv)
}

func _AreaManage_AreaInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoCreate(ctx, req.(*AreaInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoUpdate(ctx, req.(*AreaInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoDelete(ctx, req.(*AreaWithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoRead(ctx, req.(*AreaInfoReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoIndex(ctx, req.(*AreaInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AreaManage_ServiceDesc is the grpc.ServiceDesc for AreaManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AreaManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.AreaManage",
	HandlerType: (*AreaManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "areaInfoCreate",
			Handler:    _AreaManage_AreaInfoCreate_Handler,
		},
		{
			MethodName: "areaInfoUpdate",
			Handler:    _AreaManage_AreaInfoUpdate_Handler,
		},
		{
			MethodName: "areaInfoDelete",
			Handler:    _AreaManage_AreaInfoDelete_Handler,
		},
		{
			MethodName: "areaInfoRead",
			Handler:    _AreaManage_AreaInfoRead_Handler,
		},
		{
			MethodName: "areaInfoIndex",
			Handler:    _AreaManage_AreaInfoIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	TenantManage_TenantInfoCreate_FullMethodName           = "/sys.TenantManage/tenantInfoCreate"
	TenantManage_TenantInfoUpdate_FullMethodName           = "/sys.TenantManage/tenantInfoUpdate"
	TenantManage_TenantInfoDelete_FullMethodName           = "/sys.TenantManage/tenantInfoDelete"
	TenantManage_TenantInfoRead_FullMethodName             = "/sys.TenantManage/tenantInfoRead"
	TenantManage_TenantInfoIndex_FullMethodName            = "/sys.TenantManage/tenantInfoIndex"
	TenantManage_TenantAccessMultiUpdate_FullMethodName    = "/sys.TenantManage/tenantAccessMultiUpdate"
	TenantManage_TenantAccessIndex_FullMethodName          = "/sys.TenantManage/tenantAccessIndex"
	TenantManage_TenantAppIndex_FullMethodName             = "/sys.TenantManage/tenantAppIndex"
	TenantManage_TenantAppCreate_FullMethodName            = "/sys.TenantManage/tenantAppCreate"
	TenantManage_TenantAppDelete_FullMethodName            = "/sys.TenantManage/tenantAppDelete"
	TenantManage_TenantAppModuleMultiCreate_FullMethodName = "/sys.TenantManage/tenantAppModuleMultiCreate"
	TenantManage_TenantAppModuleCreate_FullMethodName      = "/sys.TenantManage/tenantAppModuleCreate"
	TenantManage_TenantAppModuleIndex_FullMethodName       = "/sys.TenantManage/tenantAppModuleIndex"
	TenantManage_TenantAppModuleDelete_FullMethodName      = "/sys.TenantManage/tenantAppModuleDelete"
	TenantManage_TenantAppMenuCreate_FullMethodName        = "/sys.TenantManage/tenantAppMenuCreate"
	TenantManage_TenantAppMenuIndex_FullMethodName         = "/sys.TenantManage/tenantAppMenuIndex"
	TenantManage_TenantAppMenuUpdate_FullMethodName        = "/sys.TenantManage/tenantAppMenuUpdate"
	TenantManage_TenantAppMenuDelete_FullMethodName        = "/sys.TenantManage/tenantAppMenuDelete"
)

// TenantManageClient is the client API for TenantManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TenantManageClient interface {
	// 新增区域
	TenantInfoCreate(ctx context.Context, in *TenantInfoCreateReq, opts ...grpc.CallOption) (*WithID, error)
	// 更新区域
	TenantInfoUpdate(ctx context.Context, in *TenantInfo, opts ...grpc.CallOption) (*Response, error)
	// 删除区域
	TenantInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Response, error)
	// 获取租户信息详情
	TenantInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*TenantInfo, error)
	// 获取租户信息列表
	TenantInfoIndex(ctx context.Context, in *TenantInfoIndexReq, opts ...grpc.CallOption) (*TenantInfoIndexResp, error)
	TenantAccessMultiUpdate(ctx context.Context, in *TenantAccessMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	TenantAccessIndex(ctx context.Context, in *TenantAccessIndexReq, opts ...grpc.CallOption) (*TenantAccessIndexResp, error)
	TenantAppIndex(ctx context.Context, in *TenantAppIndexReq, opts ...grpc.CallOption) (*TenantAppIndexResp, error)
	TenantAppCreate(ctx context.Context, in *TenantAppCreateReq, opts ...grpc.CallOption) (*Response, error)
	TenantAppDelete(ctx context.Context, in *TenantAppWithIDOrCode, opts ...grpc.CallOption) (*Response, error)
	TenantAppModuleMultiCreate(ctx context.Context, in *TenantAppCreateReq, opts ...grpc.CallOption) (*Response, error)
	TenantAppModuleCreate(ctx context.Context, in *TenantModuleCreateReq, opts ...grpc.CallOption) (*Response, error)
	TenantAppModuleIndex(ctx context.Context, in *TenantModuleIndexReq, opts ...grpc.CallOption) (*TenantModuleIndexResp, error)
	TenantAppModuleDelete(ctx context.Context, in *TenantModuleWithIDOrCode, opts ...grpc.CallOption) (*Response, error)
	TenantAppMenuCreate(ctx context.Context, in *TenantAppMenu, opts ...grpc.CallOption) (*WithID, error)
	TenantAppMenuIndex(ctx context.Context, in *TenantAppMenuIndexReq, opts ...grpc.CallOption) (*TenantAppMenuIndexResp, error)
	TenantAppMenuUpdate(ctx context.Context, in *TenantAppMenu, opts ...grpc.CallOption) (*Response, error)
	TenantAppMenuDelete(ctx context.Context, in *WithAppCodeID, opts ...grpc.CallOption) (*Response, error)
}

type tenantManageClient struct {
	cc grpc.ClientConnInterface
}

func NewTenantManageClient(cc grpc.ClientConnInterface) TenantManageClient {
	return &tenantManageClient{cc}
}

func (c *tenantManageClient) TenantInfoCreate(ctx context.Context, in *TenantInfoCreateReq, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoUpdate(ctx context.Context, in *TenantInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*TenantInfo, error) {
	out := new(TenantInfo)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoIndex(ctx context.Context, in *TenantInfoIndexReq, opts ...grpc.CallOption) (*TenantInfoIndexResp, error) {
	out := new(TenantInfoIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAccessMultiUpdate(ctx context.Context, in *TenantAccessMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAccessMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAccessIndex(ctx context.Context, in *TenantAccessIndexReq, opts ...grpc.CallOption) (*TenantAccessIndexResp, error) {
	out := new(TenantAccessIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAccessIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppIndex(ctx context.Context, in *TenantAppIndexReq, opts ...grpc.CallOption) (*TenantAppIndexResp, error) {
	out := new(TenantAppIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppCreate(ctx context.Context, in *TenantAppCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppDelete(ctx context.Context, in *TenantAppWithIDOrCode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppModuleMultiCreate(ctx context.Context, in *TenantAppCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppModuleMultiCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppModuleCreate(ctx context.Context, in *TenantModuleCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppModuleCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppModuleIndex(ctx context.Context, in *TenantModuleIndexReq, opts ...grpc.CallOption) (*TenantModuleIndexResp, error) {
	out := new(TenantModuleIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppModuleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppModuleDelete(ctx context.Context, in *TenantModuleWithIDOrCode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppModuleDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMenuCreate(ctx context.Context, in *TenantAppMenu, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMenuCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMenuIndex(ctx context.Context, in *TenantAppMenuIndexReq, opts ...grpc.CallOption) (*TenantAppMenuIndexResp, error) {
	out := new(TenantAppMenuIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMenuIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMenuUpdate(ctx context.Context, in *TenantAppMenu, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMenuUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMenuDelete(ctx context.Context, in *WithAppCodeID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMenuDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantManageServer is the server API for TenantManage service.
// All implementations must embed UnimplementedTenantManageServer
// for forward compatibility
type TenantManageServer interface {
	// 新增区域
	TenantInfoCreate(context.Context, *TenantInfoCreateReq) (*WithID, error)
	// 更新区域
	TenantInfoUpdate(context.Context, *TenantInfo) (*Response, error)
	// 删除区域
	TenantInfoDelete(context.Context, *WithIDCode) (*Response, error)
	// 获取租户信息详情
	TenantInfoRead(context.Context, *WithIDCode) (*TenantInfo, error)
	// 获取租户信息列表
	TenantInfoIndex(context.Context, *TenantInfoIndexReq) (*TenantInfoIndexResp, error)
	TenantAccessMultiUpdate(context.Context, *TenantAccessMultiUpdateReq) (*Response, error)
	TenantAccessIndex(context.Context, *TenantAccessIndexReq) (*TenantAccessIndexResp, error)
	TenantAppIndex(context.Context, *TenantAppIndexReq) (*TenantAppIndexResp, error)
	TenantAppCreate(context.Context, *TenantAppCreateReq) (*Response, error)
	TenantAppDelete(context.Context, *TenantAppWithIDOrCode) (*Response, error)
	TenantAppModuleMultiCreate(context.Context, *TenantAppCreateReq) (*Response, error)
	TenantAppModuleCreate(context.Context, *TenantModuleCreateReq) (*Response, error)
	TenantAppModuleIndex(context.Context, *TenantModuleIndexReq) (*TenantModuleIndexResp, error)
	TenantAppModuleDelete(context.Context, *TenantModuleWithIDOrCode) (*Response, error)
	TenantAppMenuCreate(context.Context, *TenantAppMenu) (*WithID, error)
	TenantAppMenuIndex(context.Context, *TenantAppMenuIndexReq) (*TenantAppMenuIndexResp, error)
	TenantAppMenuUpdate(context.Context, *TenantAppMenu) (*Response, error)
	TenantAppMenuDelete(context.Context, *WithAppCodeID) (*Response, error)
	mustEmbedUnimplementedTenantManageServer()
}

// UnimplementedTenantManageServer must be embedded to have forward compatible implementations.
type UnimplementedTenantManageServer struct {
}

func (UnimplementedTenantManageServer) TenantInfoCreate(context.Context, *TenantInfoCreateReq) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoUpdate(context.Context, *TenantInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoDelete(context.Context, *WithIDCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoDelete not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoRead(context.Context, *WithIDCode) (*TenantInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoRead not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoIndex(context.Context, *TenantInfoIndexReq) (*TenantInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAccessMultiUpdate(context.Context, *TenantAccessMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAccessMultiUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantAccessIndex(context.Context, *TenantAccessIndexReq) (*TenantAccessIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAccessIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppIndex(context.Context, *TenantAppIndexReq) (*TenantAppIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppCreate(context.Context, *TenantAppCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppDelete(context.Context, *TenantAppWithIDOrCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppDelete not implemented")
}
func (UnimplementedTenantManageServer) TenantAppModuleMultiCreate(context.Context, *TenantAppCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppModuleMultiCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppModuleCreate(context.Context, *TenantModuleCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppModuleCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppModuleIndex(context.Context, *TenantModuleIndexReq) (*TenantModuleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppModuleIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppModuleDelete(context.Context, *TenantModuleWithIDOrCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppModuleDelete not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMenuCreate(context.Context, *TenantAppMenu) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMenuCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMenuIndex(context.Context, *TenantAppMenuIndexReq) (*TenantAppMenuIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMenuIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMenuUpdate(context.Context, *TenantAppMenu) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMenuUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMenuDelete(context.Context, *WithAppCodeID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMenuDelete not implemented")
}
func (UnimplementedTenantManageServer) mustEmbedUnimplementedTenantManageServer() {}

// UnsafeTenantManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TenantManageServer will
// result in compilation errors.
type UnsafeTenantManageServer interface {
	mustEmbedUnimplementedTenantManageServer()
}

func RegisterTenantManageServer(s grpc.ServiceRegistrar, srv TenantManageServer) {
	s.RegisterService(&TenantManage_ServiceDesc, srv)
}

func _TenantManage_TenantInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfoCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoCreate(ctx, req.(*TenantInfoCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoUpdate(ctx, req.(*TenantInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoDelete(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoRead(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoIndex(ctx, req.(*TenantInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAccessMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAccessMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAccessMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAccessMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAccessMultiUpdate(ctx, req.(*TenantAccessMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAccessIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAccessIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAccessIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAccessIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAccessIndex(ctx, req.(*TenantAccessIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppIndex(ctx, req.(*TenantAppIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppCreate(ctx, req.(*TenantAppCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppWithIDOrCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppDelete(ctx, req.(*TenantAppWithIDOrCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppModuleMultiCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppModuleMultiCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppModuleMultiCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppModuleMultiCreate(ctx, req.(*TenantAppCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppModuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantModuleCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppModuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppModuleCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppModuleCreate(ctx, req.(*TenantModuleCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppModuleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantModuleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppModuleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppModuleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppModuleIndex(ctx, req.(*TenantModuleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppModuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantModuleWithIDOrCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppModuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppModuleDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppModuleDelete(ctx, req.(*TenantModuleWithIDOrCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMenuCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppMenu)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMenuCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMenuCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMenuCreate(ctx, req.(*TenantAppMenu))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMenuIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppMenuIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMenuIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMenuIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMenuIndex(ctx, req.(*TenantAppMenuIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMenuUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppMenu)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMenuUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMenuUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMenuUpdate(ctx, req.(*TenantAppMenu))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMenuDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithAppCodeID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMenuDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMenuDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMenuDelete(ctx, req.(*WithAppCodeID))
	}
	return interceptor(ctx, in, info, handler)
}

// TenantManage_ServiceDesc is the grpc.ServiceDesc for TenantManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TenantManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.TenantManage",
	HandlerType: (*TenantManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "tenantInfoCreate",
			Handler:    _TenantManage_TenantInfoCreate_Handler,
		},
		{
			MethodName: "tenantInfoUpdate",
			Handler:    _TenantManage_TenantInfoUpdate_Handler,
		},
		{
			MethodName: "tenantInfoDelete",
			Handler:    _TenantManage_TenantInfoDelete_Handler,
		},
		{
			MethodName: "tenantInfoRead",
			Handler:    _TenantManage_TenantInfoRead_Handler,
		},
		{
			MethodName: "tenantInfoIndex",
			Handler:    _TenantManage_TenantInfoIndex_Handler,
		},
		{
			MethodName: "tenantAccessMultiUpdate",
			Handler:    _TenantManage_TenantAccessMultiUpdate_Handler,
		},
		{
			MethodName: "tenantAccessIndex",
			Handler:    _TenantManage_TenantAccessIndex_Handler,
		},
		{
			MethodName: "tenantAppIndex",
			Handler:    _TenantManage_TenantAppIndex_Handler,
		},
		{
			MethodName: "tenantAppCreate",
			Handler:    _TenantManage_TenantAppCreate_Handler,
		},
		{
			MethodName: "tenantAppDelete",
			Handler:    _TenantManage_TenantAppDelete_Handler,
		},
		{
			MethodName: "tenantAppModuleMultiCreate",
			Handler:    _TenantManage_TenantAppModuleMultiCreate_Handler,
		},
		{
			MethodName: "tenantAppModuleCreate",
			Handler:    _TenantManage_TenantAppModuleCreate_Handler,
		},
		{
			MethodName: "tenantAppModuleIndex",
			Handler:    _TenantManage_TenantAppModuleIndex_Handler,
		},
		{
			MethodName: "tenantAppModuleDelete",
			Handler:    _TenantManage_TenantAppModuleDelete_Handler,
		},
		{
			MethodName: "tenantAppMenuCreate",
			Handler:    _TenantManage_TenantAppMenuCreate_Handler,
		},
		{
			MethodName: "tenantAppMenuIndex",
			Handler:    _TenantManage_TenantAppMenuIndex_Handler,
		},
		{
			MethodName: "tenantAppMenuUpdate",
			Handler:    _TenantManage_TenantAppMenuUpdate_Handler,
		},
		{
			MethodName: "tenantAppMenuDelete",
			Handler:    _TenantManage_TenantAppMenuDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}
