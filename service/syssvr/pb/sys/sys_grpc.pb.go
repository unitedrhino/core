// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.19.4
// source: proto/sys.proto

package sys

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	UserManage_UserInfoCreate_FullMethodName         = "/sys.UserManage/userInfoCreate"
	UserManage_UserInfoIndex_FullMethodName          = "/sys.UserManage/userInfoIndex"
	UserManage_UserInfoUpdate_FullMethodName         = "/sys.UserManage/userInfoUpdate"
	UserManage_UserInfoRead_FullMethodName           = "/sys.UserManage/userInfoRead"
	UserManage_UserInfoDelete_FullMethodName         = "/sys.UserManage/userInfoDelete"
	UserManage_UserLogin_FullMethodName              = "/sys.UserManage/userLogin"
	UserManage_UserForgetPwd_FullMethodName          = "/sys.UserManage/userForgetPwd"
	UserManage_UserCaptcha_FullMethodName            = "/sys.UserManage/userCaptcha"
	UserManage_UserCheckToken_FullMethodName         = "/sys.UserManage/userCheckToken"
	UserManage_UserRegister_FullMethodName           = "/sys.UserManage/userRegister"
	UserManage_UserChangePwd_FullMethodName          = "/sys.UserManage/userChangePwd"
	UserManage_UserRoleIndex_FullMethodName          = "/sys.UserManage/userRoleIndex"
	UserManage_UserRoleMultiUpdate_FullMethodName    = "/sys.UserManage/userRoleMultiUpdate"
	UserManage_UserRoleMultiCreate_FullMethodName    = "/sys.UserManage/userRoleMultiCreate"
	UserManage_UserAreaApplyCreate_FullMethodName    = "/sys.UserManage/userAreaApplyCreate"
	UserManage_UserMessageMultiIsRead_FullMethodName = "/sys.UserManage/userMessageMultiIsRead"
	UserManage_UserMessageIndex_FullMethodName       = "/sys.UserManage/userMessageIndex"
	UserManage_UserMessageStatistics_FullMethodName  = "/sys.UserManage/UserMessageStatistics"
	UserManage_UserProfileRead_FullMethodName        = "/sys.UserManage/userProfileRead"
	UserManage_UserProfileUpdate_FullMethodName      = "/sys.UserManage/userProfileUpdate"
	UserManage_UserProfileIndex_FullMethodName       = "/sys.UserManage/userProfileIndex"
)

// UserManageClient is the client API for UserManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserManageClient interface {
	UserInfoCreate(ctx context.Context, in *UserInfoCreateReq, opts ...grpc.CallOption) (*UserCreateResp, error)
	UserInfoIndex(ctx context.Context, in *UserInfoIndexReq, opts ...grpc.CallOption) (*UserInfoIndexResp, error)
	UserInfoUpdate(ctx context.Context, in *UserInfoUpdateReq, opts ...grpc.CallOption) (*Empty, error)
	UserInfoRead(ctx context.Context, in *UserInfoReadReq, opts ...grpc.CallOption) (*UserInfo, error)
	UserInfoDelete(ctx context.Context, in *UserInfoDeleteReq, opts ...grpc.CallOption) (*Empty, error)
	UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error)
	UserForgetPwd(ctx context.Context, in *UserForgetPwdReq, opts ...grpc.CallOption) (*Empty, error)
	UserCaptcha(ctx context.Context, in *UserCaptchaReq, opts ...grpc.CallOption) (*UserCaptchaResp, error)
	UserCheckToken(ctx context.Context, in *UserCheckTokenReq, opts ...grpc.CallOption) (*UserCheckTokenResp, error)
	UserRegister(ctx context.Context, in *UserRegisterReq, opts ...grpc.CallOption) (*UserRegisterResp, error)
	UserChangePwd(ctx context.Context, in *UserChangePwdReq, opts ...grpc.CallOption) (*Empty, error)
	UserRoleIndex(ctx context.Context, in *UserRoleIndexReq, opts ...grpc.CallOption) (*UserRoleIndexResp, error)
	UserRoleMultiUpdate(ctx context.Context, in *UserRoleMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error)
	UserRoleMultiCreate(ctx context.Context, in *UserRoleMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error)
	UserAreaApplyCreate(ctx context.Context, in *UserAreaApplyCreateReq, opts ...grpc.CallOption) (*Empty, error)
	UserMessageMultiIsRead(ctx context.Context, in *IDList, opts ...grpc.CallOption) (*Empty, error)
	UserMessageIndex(ctx context.Context, in *UserMessageIndexReq, opts ...grpc.CallOption) (*UserMessageIndexResp, error)
	UserMessageStatistics(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UserMessageStatisticsResp, error)
	UserProfileRead(ctx context.Context, in *WithCode, opts ...grpc.CallOption) (*UserProfile, error)
	UserProfileUpdate(ctx context.Context, in *UserProfile, opts ...grpc.CallOption) (*Empty, error)
	UserProfileIndex(ctx context.Context, in *UserProfileIndexReq, opts ...grpc.CallOption) (*UserProfileIndexResp, error)
}

type userManageClient struct {
	cc grpc.ClientConnInterface
}

func NewUserManageClient(cc grpc.ClientConnInterface) UserManageClient {
	return &userManageClient{cc}
}

func (c *userManageClient) UserInfoCreate(ctx context.Context, in *UserInfoCreateReq, opts ...grpc.CallOption) (*UserCreateResp, error) {
	out := new(UserCreateResp)
	err := c.cc.Invoke(ctx, UserManage_UserInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoIndex(ctx context.Context, in *UserInfoIndexReq, opts ...grpc.CallOption) (*UserInfoIndexResp, error) {
	out := new(UserInfoIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoUpdate(ctx context.Context, in *UserInfoUpdateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserManage_UserInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoRead(ctx context.Context, in *UserInfoReadReq, opts ...grpc.CallOption) (*UserInfo, error) {
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserManage_UserInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoDelete(ctx context.Context, in *UserInfoDeleteReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserManage_UserInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error) {
	out := new(UserLoginResp)
	err := c.cc.Invoke(ctx, UserManage_UserLogin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserForgetPwd(ctx context.Context, in *UserForgetPwdReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserManage_UserForgetPwd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserCaptcha(ctx context.Context, in *UserCaptchaReq, opts ...grpc.CallOption) (*UserCaptchaResp, error) {
	out := new(UserCaptchaResp)
	err := c.cc.Invoke(ctx, UserManage_UserCaptcha_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserCheckToken(ctx context.Context, in *UserCheckTokenReq, opts ...grpc.CallOption) (*UserCheckTokenResp, error) {
	out := new(UserCheckTokenResp)
	err := c.cc.Invoke(ctx, UserManage_UserCheckToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRegister(ctx context.Context, in *UserRegisterReq, opts ...grpc.CallOption) (*UserRegisterResp, error) {
	out := new(UserRegisterResp)
	err := c.cc.Invoke(ctx, UserManage_UserRegister_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserChangePwd(ctx context.Context, in *UserChangePwdReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserManage_UserChangePwd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRoleIndex(ctx context.Context, in *UserRoleIndexReq, opts ...grpc.CallOption) (*UserRoleIndexResp, error) {
	out := new(UserRoleIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserRoleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRoleMultiUpdate(ctx context.Context, in *UserRoleMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserManage_UserRoleMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRoleMultiCreate(ctx context.Context, in *UserRoleMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserManage_UserRoleMultiCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserAreaApplyCreate(ctx context.Context, in *UserAreaApplyCreateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserManage_UserAreaApplyCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserMessageMultiIsRead(ctx context.Context, in *IDList, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserManage_UserMessageMultiIsRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserMessageIndex(ctx context.Context, in *UserMessageIndexReq, opts ...grpc.CallOption) (*UserMessageIndexResp, error) {
	out := new(UserMessageIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserMessageIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserMessageStatistics(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UserMessageStatisticsResp, error) {
	out := new(UserMessageStatisticsResp)
	err := c.cc.Invoke(ctx, UserManage_UserMessageStatistics_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserProfileRead(ctx context.Context, in *WithCode, opts ...grpc.CallOption) (*UserProfile, error) {
	out := new(UserProfile)
	err := c.cc.Invoke(ctx, UserManage_UserProfileRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserProfileUpdate(ctx context.Context, in *UserProfile, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserManage_UserProfileUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserProfileIndex(ctx context.Context, in *UserProfileIndexReq, opts ...grpc.CallOption) (*UserProfileIndexResp, error) {
	out := new(UserProfileIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserProfileIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserManageServer is the server API for UserManage service.
// All implementations must embed UnimplementedUserManageServer
// for forward compatibility
type UserManageServer interface {
	UserInfoCreate(context.Context, *UserInfoCreateReq) (*UserCreateResp, error)
	UserInfoIndex(context.Context, *UserInfoIndexReq) (*UserInfoIndexResp, error)
	UserInfoUpdate(context.Context, *UserInfoUpdateReq) (*Empty, error)
	UserInfoRead(context.Context, *UserInfoReadReq) (*UserInfo, error)
	UserInfoDelete(context.Context, *UserInfoDeleteReq) (*Empty, error)
	UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error)
	UserForgetPwd(context.Context, *UserForgetPwdReq) (*Empty, error)
	UserCaptcha(context.Context, *UserCaptchaReq) (*UserCaptchaResp, error)
	UserCheckToken(context.Context, *UserCheckTokenReq) (*UserCheckTokenResp, error)
	UserRegister(context.Context, *UserRegisterReq) (*UserRegisterResp, error)
	UserChangePwd(context.Context, *UserChangePwdReq) (*Empty, error)
	UserRoleIndex(context.Context, *UserRoleIndexReq) (*UserRoleIndexResp, error)
	UserRoleMultiUpdate(context.Context, *UserRoleMultiUpdateReq) (*Empty, error)
	UserRoleMultiCreate(context.Context, *UserRoleMultiUpdateReq) (*Empty, error)
	UserAreaApplyCreate(context.Context, *UserAreaApplyCreateReq) (*Empty, error)
	UserMessageMultiIsRead(context.Context, *IDList) (*Empty, error)
	UserMessageIndex(context.Context, *UserMessageIndexReq) (*UserMessageIndexResp, error)
	UserMessageStatistics(context.Context, *Empty) (*UserMessageStatisticsResp, error)
	UserProfileRead(context.Context, *WithCode) (*UserProfile, error)
	UserProfileUpdate(context.Context, *UserProfile) (*Empty, error)
	UserProfileIndex(context.Context, *UserProfileIndexReq) (*UserProfileIndexResp, error)
	mustEmbedUnimplementedUserManageServer()
}

// UnimplementedUserManageServer must be embedded to have forward compatible implementations.
type UnimplementedUserManageServer struct {
}

func (UnimplementedUserManageServer) UserInfoCreate(context.Context, *UserInfoCreateReq) (*UserCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoCreate not implemented")
}
func (UnimplementedUserManageServer) UserInfoIndex(context.Context, *UserInfoIndexReq) (*UserInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoIndex not implemented")
}
func (UnimplementedUserManageServer) UserInfoUpdate(context.Context, *UserInfoUpdateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoUpdate not implemented")
}
func (UnimplementedUserManageServer) UserInfoRead(context.Context, *UserInfoReadReq) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoRead not implemented")
}
func (UnimplementedUserManageServer) UserInfoDelete(context.Context, *UserInfoDeleteReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoDelete not implemented")
}
func (UnimplementedUserManageServer) UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedUserManageServer) UserForgetPwd(context.Context, *UserForgetPwdReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserForgetPwd not implemented")
}
func (UnimplementedUserManageServer) UserCaptcha(context.Context, *UserCaptchaReq) (*UserCaptchaResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCaptcha not implemented")
}
func (UnimplementedUserManageServer) UserCheckToken(context.Context, *UserCheckTokenReq) (*UserCheckTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCheckToken not implemented")
}
func (UnimplementedUserManageServer) UserRegister(context.Context, *UserRegisterReq) (*UserRegisterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister not implemented")
}
func (UnimplementedUserManageServer) UserChangePwd(context.Context, *UserChangePwdReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserChangePwd not implemented")
}
func (UnimplementedUserManageServer) UserRoleIndex(context.Context, *UserRoleIndexReq) (*UserRoleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRoleIndex not implemented")
}
func (UnimplementedUserManageServer) UserRoleMultiUpdate(context.Context, *UserRoleMultiUpdateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRoleMultiUpdate not implemented")
}
func (UnimplementedUserManageServer) UserRoleMultiCreate(context.Context, *UserRoleMultiUpdateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRoleMultiCreate not implemented")
}
func (UnimplementedUserManageServer) UserAreaApplyCreate(context.Context, *UserAreaApplyCreateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAreaApplyCreate not implemented")
}
func (UnimplementedUserManageServer) UserMessageMultiIsRead(context.Context, *IDList) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserMessageMultiIsRead not implemented")
}
func (UnimplementedUserManageServer) UserMessageIndex(context.Context, *UserMessageIndexReq) (*UserMessageIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserMessageIndex not implemented")
}
func (UnimplementedUserManageServer) UserMessageStatistics(context.Context, *Empty) (*UserMessageStatisticsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserMessageStatistics not implemented")
}
func (UnimplementedUserManageServer) UserProfileRead(context.Context, *WithCode) (*UserProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserProfileRead not implemented")
}
func (UnimplementedUserManageServer) UserProfileUpdate(context.Context, *UserProfile) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserProfileUpdate not implemented")
}
func (UnimplementedUserManageServer) UserProfileIndex(context.Context, *UserProfileIndexReq) (*UserProfileIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserProfileIndex not implemented")
}
func (UnimplementedUserManageServer) mustEmbedUnimplementedUserManageServer() {}

// UnsafeUserManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserManageServer will
// result in compilation errors.
type UnsafeUserManageServer interface {
	mustEmbedUnimplementedUserManageServer()
}

func RegisterUserManageServer(s grpc.ServiceRegistrar, srv UserManageServer) {
	s.RegisterService(&UserManage_ServiceDesc, srv)
}

func _UserManage_UserInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoCreate(ctx, req.(*UserInfoCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoIndex(ctx, req.(*UserInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoUpdate(ctx, req.(*UserInfoUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoRead(ctx, req.(*UserInfoReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoDelete(ctx, req.(*UserInfoDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserLogin(ctx, req.(*UserLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserForgetPwd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserForgetPwdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserForgetPwd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserForgetPwd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserForgetPwd(ctx, req.(*UserForgetPwdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserCaptcha_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCaptchaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserCaptcha(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserCaptcha_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserCaptcha(ctx, req.(*UserCaptchaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserCheckToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCheckTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserCheckToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserCheckToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserCheckToken(ctx, req.(*UserCheckTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRegister(ctx, req.(*UserRegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserChangePwd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserChangePwdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserChangePwd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserChangePwd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserChangePwd(ctx, req.(*UserChangePwdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRoleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRoleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRoleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRoleIndex(ctx, req.(*UserRoleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRoleMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRoleMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRoleMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRoleMultiUpdate(ctx, req.(*UserRoleMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRoleMultiCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRoleMultiCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRoleMultiCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRoleMultiCreate(ctx, req.(*UserRoleMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserAreaApplyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAreaApplyCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserAreaApplyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserAreaApplyCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserAreaApplyCreate(ctx, req.(*UserAreaApplyCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserMessageMultiIsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserMessageMultiIsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserMessageMultiIsRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserMessageMultiIsRead(ctx, req.(*IDList))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserMessageIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserMessageIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserMessageIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserMessageIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserMessageIndex(ctx, req.(*UserMessageIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserMessageStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserMessageStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserMessageStatistics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserMessageStatistics(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserProfileRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserProfileRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserProfileRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserProfileRead(ctx, req.(*WithCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserProfileUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserProfileUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserProfileUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserProfileUpdate(ctx, req.(*UserProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserProfileIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserProfileIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserProfileIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserProfileIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserProfileIndex(ctx, req.(*UserProfileIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserManage_ServiceDesc is the grpc.ServiceDesc for UserManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.UserManage",
	HandlerType: (*UserManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "userInfoCreate",
			Handler:    _UserManage_UserInfoCreate_Handler,
		},
		{
			MethodName: "userInfoIndex",
			Handler:    _UserManage_UserInfoIndex_Handler,
		},
		{
			MethodName: "userInfoUpdate",
			Handler:    _UserManage_UserInfoUpdate_Handler,
		},
		{
			MethodName: "userInfoRead",
			Handler:    _UserManage_UserInfoRead_Handler,
		},
		{
			MethodName: "userInfoDelete",
			Handler:    _UserManage_UserInfoDelete_Handler,
		},
		{
			MethodName: "userLogin",
			Handler:    _UserManage_UserLogin_Handler,
		},
		{
			MethodName: "userForgetPwd",
			Handler:    _UserManage_UserForgetPwd_Handler,
		},
		{
			MethodName: "userCaptcha",
			Handler:    _UserManage_UserCaptcha_Handler,
		},
		{
			MethodName: "userCheckToken",
			Handler:    _UserManage_UserCheckToken_Handler,
		},
		{
			MethodName: "userRegister",
			Handler:    _UserManage_UserRegister_Handler,
		},
		{
			MethodName: "userChangePwd",
			Handler:    _UserManage_UserChangePwd_Handler,
		},
		{
			MethodName: "userRoleIndex",
			Handler:    _UserManage_UserRoleIndex_Handler,
		},
		{
			MethodName: "userRoleMultiUpdate",
			Handler:    _UserManage_UserRoleMultiUpdate_Handler,
		},
		{
			MethodName: "userRoleMultiCreate",
			Handler:    _UserManage_UserRoleMultiCreate_Handler,
		},
		{
			MethodName: "userAreaApplyCreate",
			Handler:    _UserManage_UserAreaApplyCreate_Handler,
		},
		{
			MethodName: "userMessageMultiIsRead",
			Handler:    _UserManage_UserMessageMultiIsRead_Handler,
		},
		{
			MethodName: "userMessageIndex",
			Handler:    _UserManage_UserMessageIndex_Handler,
		},
		{
			MethodName: "UserMessageStatistics",
			Handler:    _UserManage_UserMessageStatistics_Handler,
		},
		{
			MethodName: "userProfileRead",
			Handler:    _UserManage_UserProfileRead_Handler,
		},
		{
			MethodName: "userProfileUpdate",
			Handler:    _UserManage_UserProfileUpdate_Handler,
		},
		{
			MethodName: "userProfileIndex",
			Handler:    _UserManage_UserProfileIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	DataManage_DataProjectMultiUpdate_FullMethodName = "/sys.DataManage/dataProjectMultiUpdate"
	DataManage_DataProjectIndex_FullMethodName       = "/sys.DataManage/dataProjectIndex"
	DataManage_DataAreaMultiUpdate_FullMethodName    = "/sys.DataManage/dataAreaMultiUpdate"
	DataManage_DataAreaIndex_FullMethodName          = "/sys.DataManage/dataAreaIndex"
	DataManage_DataAreaMultiDelete_FullMethodName    = "/sys.DataManage/dataAreaMultiDelete"
	DataManage_UserAreaApplyIndex_FullMethodName     = "/sys.DataManage/userAreaApplyIndex"
	DataManage_UserAreaApplyDeal_FullMethodName      = "/sys.DataManage/userAreaApplyDeal"
)

// DataManageClient is the client API for DataManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataManageClient interface {
	DataProjectMultiUpdate(ctx context.Context, in *DataProjectMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error)
	DataProjectIndex(ctx context.Context, in *DataProjectIndexReq, opts ...grpc.CallOption) (*DataProjectIndexResp, error)
	DataAreaMultiUpdate(ctx context.Context, in *DataAreaMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error)
	DataAreaIndex(ctx context.Context, in *DataAreaIndexReq, opts ...grpc.CallOption) (*DataAreaIndexResp, error)
	DataAreaMultiDelete(ctx context.Context, in *DataAreaMultiDeleteReq, opts ...grpc.CallOption) (*Empty, error)
	UserAreaApplyIndex(ctx context.Context, in *UserAreaApplyIndexReq, opts ...grpc.CallOption) (*UserAreaApplyIndexResp, error)
	UserAreaApplyDeal(ctx context.Context, in *UserAreaApplyDealReq, opts ...grpc.CallOption) (*Empty, error)
}

type dataManageClient struct {
	cc grpc.ClientConnInterface
}

func NewDataManageClient(cc grpc.ClientConnInterface) DataManageClient {
	return &dataManageClient{cc}
}

func (c *dataManageClient) DataProjectMultiUpdate(ctx context.Context, in *DataProjectMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, DataManage_DataProjectMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataManageClient) DataProjectIndex(ctx context.Context, in *DataProjectIndexReq, opts ...grpc.CallOption) (*DataProjectIndexResp, error) {
	out := new(DataProjectIndexResp)
	err := c.cc.Invoke(ctx, DataManage_DataProjectIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataManageClient) DataAreaMultiUpdate(ctx context.Context, in *DataAreaMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, DataManage_DataAreaMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataManageClient) DataAreaIndex(ctx context.Context, in *DataAreaIndexReq, opts ...grpc.CallOption) (*DataAreaIndexResp, error) {
	out := new(DataAreaIndexResp)
	err := c.cc.Invoke(ctx, DataManage_DataAreaIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataManageClient) DataAreaMultiDelete(ctx context.Context, in *DataAreaMultiDeleteReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, DataManage_DataAreaMultiDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataManageClient) UserAreaApplyIndex(ctx context.Context, in *UserAreaApplyIndexReq, opts ...grpc.CallOption) (*UserAreaApplyIndexResp, error) {
	out := new(UserAreaApplyIndexResp)
	err := c.cc.Invoke(ctx, DataManage_UserAreaApplyIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataManageClient) UserAreaApplyDeal(ctx context.Context, in *UserAreaApplyDealReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, DataManage_UserAreaApplyDeal_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataManageServer is the server API for DataManage service.
// All implementations must embed UnimplementedDataManageServer
// for forward compatibility
type DataManageServer interface {
	DataProjectMultiUpdate(context.Context, *DataProjectMultiUpdateReq) (*Empty, error)
	DataProjectIndex(context.Context, *DataProjectIndexReq) (*DataProjectIndexResp, error)
	DataAreaMultiUpdate(context.Context, *DataAreaMultiUpdateReq) (*Empty, error)
	DataAreaIndex(context.Context, *DataAreaIndexReq) (*DataAreaIndexResp, error)
	DataAreaMultiDelete(context.Context, *DataAreaMultiDeleteReq) (*Empty, error)
	UserAreaApplyIndex(context.Context, *UserAreaApplyIndexReq) (*UserAreaApplyIndexResp, error)
	UserAreaApplyDeal(context.Context, *UserAreaApplyDealReq) (*Empty, error)
	mustEmbedUnimplementedDataManageServer()
}

// UnimplementedDataManageServer must be embedded to have forward compatible implementations.
type UnimplementedDataManageServer struct {
}

func (UnimplementedDataManageServer) DataProjectMultiUpdate(context.Context, *DataProjectMultiUpdateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataProjectMultiUpdate not implemented")
}
func (UnimplementedDataManageServer) DataProjectIndex(context.Context, *DataProjectIndexReq) (*DataProjectIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataProjectIndex not implemented")
}
func (UnimplementedDataManageServer) DataAreaMultiUpdate(context.Context, *DataAreaMultiUpdateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataAreaMultiUpdate not implemented")
}
func (UnimplementedDataManageServer) DataAreaIndex(context.Context, *DataAreaIndexReq) (*DataAreaIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataAreaIndex not implemented")
}
func (UnimplementedDataManageServer) DataAreaMultiDelete(context.Context, *DataAreaMultiDeleteReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataAreaMultiDelete not implemented")
}
func (UnimplementedDataManageServer) UserAreaApplyIndex(context.Context, *UserAreaApplyIndexReq) (*UserAreaApplyIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAreaApplyIndex not implemented")
}
func (UnimplementedDataManageServer) UserAreaApplyDeal(context.Context, *UserAreaApplyDealReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAreaApplyDeal not implemented")
}
func (UnimplementedDataManageServer) mustEmbedUnimplementedDataManageServer() {}

// UnsafeDataManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataManageServer will
// result in compilation errors.
type UnsafeDataManageServer interface {
	mustEmbedUnimplementedDataManageServer()
}

func RegisterDataManageServer(s grpc.ServiceRegistrar, srv DataManageServer) {
	s.RegisterService(&DataManage_ServiceDesc, srv)
}

func _DataManage_DataProjectMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataProjectMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).DataProjectMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_DataProjectMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).DataProjectMultiUpdate(ctx, req.(*DataProjectMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataManage_DataProjectIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataProjectIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).DataProjectIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_DataProjectIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).DataProjectIndex(ctx, req.(*DataProjectIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataManage_DataAreaMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataAreaMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).DataAreaMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_DataAreaMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).DataAreaMultiUpdate(ctx, req.(*DataAreaMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataManage_DataAreaIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataAreaIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).DataAreaIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_DataAreaIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).DataAreaIndex(ctx, req.(*DataAreaIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataManage_DataAreaMultiDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataAreaMultiDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).DataAreaMultiDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_DataAreaMultiDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).DataAreaMultiDelete(ctx, req.(*DataAreaMultiDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataManage_UserAreaApplyIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAreaApplyIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).UserAreaApplyIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_UserAreaApplyIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).UserAreaApplyIndex(ctx, req.(*UserAreaApplyIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataManage_UserAreaApplyDeal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAreaApplyDealReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataManageServer).UserAreaApplyDeal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataManage_UserAreaApplyDeal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataManageServer).UserAreaApplyDeal(ctx, req.(*UserAreaApplyDealReq))
	}
	return interceptor(ctx, in, info, handler)
}

// DataManage_ServiceDesc is the grpc.ServiceDesc for DataManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.DataManage",
	HandlerType: (*DataManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "dataProjectMultiUpdate",
			Handler:    _DataManage_DataProjectMultiUpdate_Handler,
		},
		{
			MethodName: "dataProjectIndex",
			Handler:    _DataManage_DataProjectIndex_Handler,
		},
		{
			MethodName: "dataAreaMultiUpdate",
			Handler:    _DataManage_DataAreaMultiUpdate_Handler,
		},
		{
			MethodName: "dataAreaIndex",
			Handler:    _DataManage_DataAreaIndex_Handler,
		},
		{
			MethodName: "dataAreaMultiDelete",
			Handler:    _DataManage_DataAreaMultiDelete_Handler,
		},
		{
			MethodName: "userAreaApplyIndex",
			Handler:    _DataManage_UserAreaApplyIndex_Handler,
		},
		{
			MethodName: "userAreaApplyDeal",
			Handler:    _DataManage_UserAreaApplyDeal_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	NotifyManage_MessageInfoSend_FullMethodName      = "/sys.NotifyManage/messageInfoSend"
	NotifyManage_MessageInfoIndex_FullMethodName     = "/sys.NotifyManage/messageInfoIndex"
	NotifyManage_MessageInfoUpdate_FullMethodName    = "/sys.NotifyManage/messageInfoUpdate"
	NotifyManage_MessageInfoDelete_FullMethodName    = "/sys.NotifyManage/messageInfoDelete"
	NotifyManage_NotifyInfoRead_FullMethodName       = "/sys.NotifyManage/notifyInfoRead"
	NotifyManage_NotifyInfoCreate_FullMethodName     = "/sys.NotifyManage/notifyInfoCreate"
	NotifyManage_NotifyInfoUpdate_FullMethodName     = "/sys.NotifyManage/notifyInfoUpdate"
	NotifyManage_NotifyInfoIndex_FullMethodName      = "/sys.NotifyManage/notifyInfoIndex"
	NotifyManage_NotifyInfoDelete_FullMethodName     = "/sys.NotifyManage/notifyInfoDelete"
	NotifyManage_NotifyInfoSend_FullMethodName       = "/sys.NotifyManage/notifyInfoSend"
	NotifyManage_NotifyTemplateRead_FullMethodName   = "/sys.NotifyManage/notifyTemplateRead"
	NotifyManage_NotifyTemplateCreate_FullMethodName = "/sys.NotifyManage/notifyTemplateCreate"
	NotifyManage_NotifyTemplateUpdate_FullMethodName = "/sys.NotifyManage/notifyTemplateUpdate"
	NotifyManage_NotifyTemplateIndex_FullMethodName  = "/sys.NotifyManage/notifyTemplateIndex"
	NotifyManage_NotifyTemplateDelete_FullMethodName = "/sys.NotifyManage/notifyTemplateDelete"
)

// NotifyManageClient is the client API for NotifyManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotifyManageClient interface {
	// 站内信
	MessageInfoSend(ctx context.Context, in *MessageInfoSendReq, opts ...grpc.CallOption) (*WithID, error)
	MessageInfoIndex(ctx context.Context, in *MessageInfoIndexReq, opts ...grpc.CallOption) (*MessageInfoIndexResp, error)
	MessageInfoUpdate(ctx context.Context, in *MessageInfo, opts ...grpc.CallOption) (*Empty, error)
	MessageInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error)
	// 通知配置信息
	NotifyInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*NotifyInfo, error)
	NotifyInfoCreate(ctx context.Context, in *NotifyInfo, opts ...grpc.CallOption) (*WithID, error)
	NotifyInfoUpdate(ctx context.Context, in *NotifyInfo, opts ...grpc.CallOption) (*Empty, error)
	NotifyInfoIndex(ctx context.Context, in *NotifyInfoIndexReq, opts ...grpc.CallOption) (*NotifyInfoIndexResp, error)
	NotifyInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error)
	NotifyInfoSend(ctx context.Context, in *NotifyInfoSendReq, opts ...grpc.CallOption) (*Empty, error)
	// 通知模版
	NotifyTemplateRead(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*NotifyTemplate, error)
	NotifyTemplateCreate(ctx context.Context, in *NotifyTemplate, opts ...grpc.CallOption) (*WithID, error)
	NotifyTemplateUpdate(ctx context.Context, in *NotifyTemplate, opts ...grpc.CallOption) (*Empty, error)
	NotifyTemplateIndex(ctx context.Context, in *NotifyTemplateIndexReq, opts ...grpc.CallOption) (*NotifyTemplateIndexResp, error)
	NotifyTemplateDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error)
}

type notifyManageClient struct {
	cc grpc.ClientConnInterface
}

func NewNotifyManageClient(cc grpc.ClientConnInterface) NotifyManageClient {
	return &notifyManageClient{cc}
}

func (c *notifyManageClient) MessageInfoSend(ctx context.Context, in *MessageInfoSendReq, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, NotifyManage_MessageInfoSend_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) MessageInfoIndex(ctx context.Context, in *MessageInfoIndexReq, opts ...grpc.CallOption) (*MessageInfoIndexResp, error) {
	out := new(MessageInfoIndexResp)
	err := c.cc.Invoke(ctx, NotifyManage_MessageInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) MessageInfoUpdate(ctx context.Context, in *MessageInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotifyManage_MessageInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) MessageInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotifyManage_MessageInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) NotifyInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*NotifyInfo, error) {
	out := new(NotifyInfo)
	err := c.cc.Invoke(ctx, NotifyManage_NotifyInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) NotifyInfoCreate(ctx context.Context, in *NotifyInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, NotifyManage_NotifyInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) NotifyInfoUpdate(ctx context.Context, in *NotifyInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotifyManage_NotifyInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) NotifyInfoIndex(ctx context.Context, in *NotifyInfoIndexReq, opts ...grpc.CallOption) (*NotifyInfoIndexResp, error) {
	out := new(NotifyInfoIndexResp)
	err := c.cc.Invoke(ctx, NotifyManage_NotifyInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) NotifyInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotifyManage_NotifyInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) NotifyInfoSend(ctx context.Context, in *NotifyInfoSendReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotifyManage_NotifyInfoSend_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) NotifyTemplateRead(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*NotifyTemplate, error) {
	out := new(NotifyTemplate)
	err := c.cc.Invoke(ctx, NotifyManage_NotifyTemplateRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) NotifyTemplateCreate(ctx context.Context, in *NotifyTemplate, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, NotifyManage_NotifyTemplateCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) NotifyTemplateUpdate(ctx context.Context, in *NotifyTemplate, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotifyManage_NotifyTemplateUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) NotifyTemplateIndex(ctx context.Context, in *NotifyTemplateIndexReq, opts ...grpc.CallOption) (*NotifyTemplateIndexResp, error) {
	out := new(NotifyTemplateIndexResp)
	err := c.cc.Invoke(ctx, NotifyManage_NotifyTemplateIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notifyManageClient) NotifyTemplateDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, NotifyManage_NotifyTemplateDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotifyManageServer is the server API for NotifyManage service.
// All implementations must embed UnimplementedNotifyManageServer
// for forward compatibility
type NotifyManageServer interface {
	// 站内信
	MessageInfoSend(context.Context, *MessageInfoSendReq) (*WithID, error)
	MessageInfoIndex(context.Context, *MessageInfoIndexReq) (*MessageInfoIndexResp, error)
	MessageInfoUpdate(context.Context, *MessageInfo) (*Empty, error)
	MessageInfoDelete(context.Context, *WithID) (*Empty, error)
	// 通知配置信息
	NotifyInfoRead(context.Context, *WithIDCode) (*NotifyInfo, error)
	NotifyInfoCreate(context.Context, *NotifyInfo) (*WithID, error)
	NotifyInfoUpdate(context.Context, *NotifyInfo) (*Empty, error)
	NotifyInfoIndex(context.Context, *NotifyInfoIndexReq) (*NotifyInfoIndexResp, error)
	NotifyInfoDelete(context.Context, *WithID) (*Empty, error)
	NotifyInfoSend(context.Context, *NotifyInfoSendReq) (*Empty, error)
	// 通知模版
	NotifyTemplateRead(context.Context, *WithID) (*NotifyTemplate, error)
	NotifyTemplateCreate(context.Context, *NotifyTemplate) (*WithID, error)
	NotifyTemplateUpdate(context.Context, *NotifyTemplate) (*Empty, error)
	NotifyTemplateIndex(context.Context, *NotifyTemplateIndexReq) (*NotifyTemplateIndexResp, error)
	NotifyTemplateDelete(context.Context, *WithID) (*Empty, error)
	mustEmbedUnimplementedNotifyManageServer()
}

// UnimplementedNotifyManageServer must be embedded to have forward compatible implementations.
type UnimplementedNotifyManageServer struct {
}

func (UnimplementedNotifyManageServer) MessageInfoSend(context.Context, *MessageInfoSendReq) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageInfoSend not implemented")
}
func (UnimplementedNotifyManageServer) MessageInfoIndex(context.Context, *MessageInfoIndexReq) (*MessageInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageInfoIndex not implemented")
}
func (UnimplementedNotifyManageServer) MessageInfoUpdate(context.Context, *MessageInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageInfoUpdate not implemented")
}
func (UnimplementedNotifyManageServer) MessageInfoDelete(context.Context, *WithID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageInfoDelete not implemented")
}
func (UnimplementedNotifyManageServer) NotifyInfoRead(context.Context, *WithIDCode) (*NotifyInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyInfoRead not implemented")
}
func (UnimplementedNotifyManageServer) NotifyInfoCreate(context.Context, *NotifyInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyInfoCreate not implemented")
}
func (UnimplementedNotifyManageServer) NotifyInfoUpdate(context.Context, *NotifyInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyInfoUpdate not implemented")
}
func (UnimplementedNotifyManageServer) NotifyInfoIndex(context.Context, *NotifyInfoIndexReq) (*NotifyInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyInfoIndex not implemented")
}
func (UnimplementedNotifyManageServer) NotifyInfoDelete(context.Context, *WithID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyInfoDelete not implemented")
}
func (UnimplementedNotifyManageServer) NotifyInfoSend(context.Context, *NotifyInfoSendReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyInfoSend not implemented")
}
func (UnimplementedNotifyManageServer) NotifyTemplateRead(context.Context, *WithID) (*NotifyTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyTemplateRead not implemented")
}
func (UnimplementedNotifyManageServer) NotifyTemplateCreate(context.Context, *NotifyTemplate) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyTemplateCreate not implemented")
}
func (UnimplementedNotifyManageServer) NotifyTemplateUpdate(context.Context, *NotifyTemplate) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyTemplateUpdate not implemented")
}
func (UnimplementedNotifyManageServer) NotifyTemplateIndex(context.Context, *NotifyTemplateIndexReq) (*NotifyTemplateIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyTemplateIndex not implemented")
}
func (UnimplementedNotifyManageServer) NotifyTemplateDelete(context.Context, *WithID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyTemplateDelete not implemented")
}
func (UnimplementedNotifyManageServer) mustEmbedUnimplementedNotifyManageServer() {}

// UnsafeNotifyManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotifyManageServer will
// result in compilation errors.
type UnsafeNotifyManageServer interface {
	mustEmbedUnimplementedNotifyManageServer()
}

func RegisterNotifyManageServer(s grpc.ServiceRegistrar, srv NotifyManageServer) {
	s.RegisterService(&NotifyManage_ServiceDesc, srv)
}

func _NotifyManage_MessageInfoSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageInfoSendReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).MessageInfoSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_MessageInfoSend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).MessageInfoSend(ctx, req.(*MessageInfoSendReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_MessageInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).MessageInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_MessageInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).MessageInfoIndex(ctx, req.(*MessageInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_MessageInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).MessageInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_MessageInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).MessageInfoUpdate(ctx, req.(*MessageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_MessageInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).MessageInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_MessageInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).MessageInfoDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_NotifyInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).NotifyInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_NotifyInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).NotifyInfoRead(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_NotifyInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).NotifyInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_NotifyInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).NotifyInfoCreate(ctx, req.(*NotifyInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_NotifyInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).NotifyInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_NotifyInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).NotifyInfoUpdate(ctx, req.(*NotifyInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_NotifyInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).NotifyInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_NotifyInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).NotifyInfoIndex(ctx, req.(*NotifyInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_NotifyInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).NotifyInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_NotifyInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).NotifyInfoDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_NotifyInfoSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyInfoSendReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).NotifyInfoSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_NotifyInfoSend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).NotifyInfoSend(ctx, req.(*NotifyInfoSendReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_NotifyTemplateRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).NotifyTemplateRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_NotifyTemplateRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).NotifyTemplateRead(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_NotifyTemplateCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).NotifyTemplateCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_NotifyTemplateCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).NotifyTemplateCreate(ctx, req.(*NotifyTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_NotifyTemplateUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).NotifyTemplateUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_NotifyTemplateUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).NotifyTemplateUpdate(ctx, req.(*NotifyTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_NotifyTemplateIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyTemplateIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).NotifyTemplateIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_NotifyTemplateIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).NotifyTemplateIndex(ctx, req.(*NotifyTemplateIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotifyManage_NotifyTemplateDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotifyManageServer).NotifyTemplateDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotifyManage_NotifyTemplateDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotifyManageServer).NotifyTemplateDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

// NotifyManage_ServiceDesc is the grpc.ServiceDesc for NotifyManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NotifyManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.NotifyManage",
	HandlerType: (*NotifyManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "messageInfoSend",
			Handler:    _NotifyManage_MessageInfoSend_Handler,
		},
		{
			MethodName: "messageInfoIndex",
			Handler:    _NotifyManage_MessageInfoIndex_Handler,
		},
		{
			MethodName: "messageInfoUpdate",
			Handler:    _NotifyManage_MessageInfoUpdate_Handler,
		},
		{
			MethodName: "messageInfoDelete",
			Handler:    _NotifyManage_MessageInfoDelete_Handler,
		},
		{
			MethodName: "notifyInfoRead",
			Handler:    _NotifyManage_NotifyInfoRead_Handler,
		},
		{
			MethodName: "notifyInfoCreate",
			Handler:    _NotifyManage_NotifyInfoCreate_Handler,
		},
		{
			MethodName: "notifyInfoUpdate",
			Handler:    _NotifyManage_NotifyInfoUpdate_Handler,
		},
		{
			MethodName: "notifyInfoIndex",
			Handler:    _NotifyManage_NotifyInfoIndex_Handler,
		},
		{
			MethodName: "notifyInfoDelete",
			Handler:    _NotifyManage_NotifyInfoDelete_Handler,
		},
		{
			MethodName: "notifyInfoSend",
			Handler:    _NotifyManage_NotifyInfoSend_Handler,
		},
		{
			MethodName: "notifyTemplateRead",
			Handler:    _NotifyManage_NotifyTemplateRead_Handler,
		},
		{
			MethodName: "notifyTemplateCreate",
			Handler:    _NotifyManage_NotifyTemplateCreate_Handler,
		},
		{
			MethodName: "notifyTemplateUpdate",
			Handler:    _NotifyManage_NotifyTemplateUpdate_Handler,
		},
		{
			MethodName: "notifyTemplateIndex",
			Handler:    _NotifyManage_NotifyTemplateIndex_Handler,
		},
		{
			MethodName: "notifyTemplateDelete",
			Handler:    _NotifyManage_NotifyTemplateDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	AccessManage_ApiInfoCreate_FullMethodName    = "/sys.AccessManage/apiInfoCreate"
	AccessManage_ApiInfoIndex_FullMethodName     = "/sys.AccessManage/apiInfoIndex"
	AccessManage_ApiInfoUpdate_FullMethodName    = "/sys.AccessManage/apiInfoUpdate"
	AccessManage_ApiInfoDelete_FullMethodName    = "/sys.AccessManage/apiInfoDelete"
	AccessManage_AccessInfoCreate_FullMethodName = "/sys.AccessManage/accessInfoCreate"
	AccessManage_AccessInfoIndex_FullMethodName  = "/sys.AccessManage/accessInfoIndex"
	AccessManage_AccessInfoUpdate_FullMethodName = "/sys.AccessManage/accessInfoUpdate"
	AccessManage_AccessInfoDelete_FullMethodName = "/sys.AccessManage/accessInfoDelete"
)

// AccessManageClient is the client API for AccessManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccessManageClient interface {
	ApiInfoCreate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*WithID, error)
	ApiInfoIndex(ctx context.Context, in *ApiInfoIndexReq, opts ...grpc.CallOption) (*ApiInfoIndexResp, error)
	ApiInfoUpdate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*Empty, error)
	ApiInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error)
	AccessInfoCreate(ctx context.Context, in *AccessInfo, opts ...grpc.CallOption) (*WithID, error)
	AccessInfoIndex(ctx context.Context, in *AccessInfoIndexReq, opts ...grpc.CallOption) (*AccessInfoIndexResp, error)
	AccessInfoUpdate(ctx context.Context, in *AccessInfo, opts ...grpc.CallOption) (*Empty, error)
	AccessInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error)
}

type accessManageClient struct {
	cc grpc.ClientConnInterface
}

func NewAccessManageClient(cc grpc.ClientConnInterface) AccessManageClient {
	return &accessManageClient{cc}
}

func (c *accessManageClient) ApiInfoCreate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, AccessManage_ApiInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) ApiInfoIndex(ctx context.Context, in *ApiInfoIndexReq, opts ...grpc.CallOption) (*ApiInfoIndexResp, error) {
	out := new(ApiInfoIndexResp)
	err := c.cc.Invoke(ctx, AccessManage_ApiInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) ApiInfoUpdate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccessManage_ApiInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) ApiInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccessManage_ApiInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) AccessInfoCreate(ctx context.Context, in *AccessInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, AccessManage_AccessInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) AccessInfoIndex(ctx context.Context, in *AccessInfoIndexReq, opts ...grpc.CallOption) (*AccessInfoIndexResp, error) {
	out := new(AccessInfoIndexResp)
	err := c.cc.Invoke(ctx, AccessManage_AccessInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) AccessInfoUpdate(ctx context.Context, in *AccessInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccessManage_AccessInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessManageClient) AccessInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, AccessManage_AccessInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccessManageServer is the server API for AccessManage service.
// All implementations must embed UnimplementedAccessManageServer
// for forward compatibility
type AccessManageServer interface {
	ApiInfoCreate(context.Context, *ApiInfo) (*WithID, error)
	ApiInfoIndex(context.Context, *ApiInfoIndexReq) (*ApiInfoIndexResp, error)
	ApiInfoUpdate(context.Context, *ApiInfo) (*Empty, error)
	ApiInfoDelete(context.Context, *WithID) (*Empty, error)
	AccessInfoCreate(context.Context, *AccessInfo) (*WithID, error)
	AccessInfoIndex(context.Context, *AccessInfoIndexReq) (*AccessInfoIndexResp, error)
	AccessInfoUpdate(context.Context, *AccessInfo) (*Empty, error)
	AccessInfoDelete(context.Context, *WithID) (*Empty, error)
	mustEmbedUnimplementedAccessManageServer()
}

// UnimplementedAccessManageServer must be embedded to have forward compatible implementations.
type UnimplementedAccessManageServer struct {
}

func (UnimplementedAccessManageServer) ApiInfoCreate(context.Context, *ApiInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoCreate not implemented")
}
func (UnimplementedAccessManageServer) ApiInfoIndex(context.Context, *ApiInfoIndexReq) (*ApiInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoIndex not implemented")
}
func (UnimplementedAccessManageServer) ApiInfoUpdate(context.Context, *ApiInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoUpdate not implemented")
}
func (UnimplementedAccessManageServer) ApiInfoDelete(context.Context, *WithID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoDelete not implemented")
}
func (UnimplementedAccessManageServer) AccessInfoCreate(context.Context, *AccessInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessInfoCreate not implemented")
}
func (UnimplementedAccessManageServer) AccessInfoIndex(context.Context, *AccessInfoIndexReq) (*AccessInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessInfoIndex not implemented")
}
func (UnimplementedAccessManageServer) AccessInfoUpdate(context.Context, *AccessInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessInfoUpdate not implemented")
}
func (UnimplementedAccessManageServer) AccessInfoDelete(context.Context, *WithID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessInfoDelete not implemented")
}
func (UnimplementedAccessManageServer) mustEmbedUnimplementedAccessManageServer() {}

// UnsafeAccessManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccessManageServer will
// result in compilation errors.
type UnsafeAccessManageServer interface {
	mustEmbedUnimplementedAccessManageServer()
}

func RegisterAccessManageServer(s grpc.ServiceRegistrar, srv AccessManageServer) {
	s.RegisterService(&AccessManage_ServiceDesc, srv)
}

func _AccessManage_ApiInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).ApiInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_ApiInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).ApiInfoCreate(ctx, req.(*ApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_ApiInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).ApiInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_ApiInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).ApiInfoIndex(ctx, req.(*ApiInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_ApiInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).ApiInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_ApiInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).ApiInfoUpdate(ctx, req.(*ApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_ApiInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).ApiInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_ApiInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).ApiInfoDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_AccessInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).AccessInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_AccessInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).AccessInfoCreate(ctx, req.(*AccessInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_AccessInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).AccessInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_AccessInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).AccessInfoIndex(ctx, req.(*AccessInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_AccessInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).AccessInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_AccessInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).AccessInfoUpdate(ctx, req.(*AccessInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessManage_AccessInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessManageServer).AccessInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccessManage_AccessInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessManageServer).AccessInfoDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

// AccessManage_ServiceDesc is the grpc.ServiceDesc for AccessManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccessManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.AccessManage",
	HandlerType: (*AccessManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "apiInfoCreate",
			Handler:    _AccessManage_ApiInfoCreate_Handler,
		},
		{
			MethodName: "apiInfoIndex",
			Handler:    _AccessManage_ApiInfoIndex_Handler,
		},
		{
			MethodName: "apiInfoUpdate",
			Handler:    _AccessManage_ApiInfoUpdate_Handler,
		},
		{
			MethodName: "apiInfoDelete",
			Handler:    _AccessManage_ApiInfoDelete_Handler,
		},
		{
			MethodName: "accessInfoCreate",
			Handler:    _AccessManage_AccessInfoCreate_Handler,
		},
		{
			MethodName: "accessInfoIndex",
			Handler:    _AccessManage_AccessInfoIndex_Handler,
		},
		{
			MethodName: "accessInfoUpdate",
			Handler:    _AccessManage_AccessInfoUpdate_Handler,
		},
		{
			MethodName: "accessInfoDelete",
			Handler:    _AccessManage_AccessInfoDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	RoleManage_RoleInfoCreate_FullMethodName        = "/sys.RoleManage/roleInfoCreate"
	RoleManage_RoleInfoIndex_FullMethodName         = "/sys.RoleManage/roleInfoIndex"
	RoleManage_RoleInfoUpdate_FullMethodName        = "/sys.RoleManage/roleInfoUpdate"
	RoleManage_RoleInfoDelete_FullMethodName        = "/sys.RoleManage/roleInfoDelete"
	RoleManage_RoleMenuIndex_FullMethodName         = "/sys.RoleManage/roleMenuIndex"
	RoleManage_RoleMenuMultiUpdate_FullMethodName   = "/sys.RoleManage/roleMenuMultiUpdate"
	RoleManage_RoleAppIndex_FullMethodName          = "/sys.RoleManage/roleAppIndex"
	RoleManage_RoleAppMultiUpdate_FullMethodName    = "/sys.RoleManage/roleAppMultiUpdate"
	RoleManage_RoleModuleIndex_FullMethodName       = "/sys.RoleManage/roleModuleIndex"
	RoleManage_RoleModuleMultiUpdate_FullMethodName = "/sys.RoleManage/roleModuleMultiUpdate"
	RoleManage_RoleApiAuth_FullMethodName           = "/sys.RoleManage/roleApiAuth"
	RoleManage_RoleAccessMultiUpdate_FullMethodName = "/sys.RoleManage/roleAccessMultiUpdate"
	RoleManage_RoleAccessIndex_FullMethodName       = "/sys.RoleManage/roleAccessIndex"
)

// RoleManageClient is the client API for RoleManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleManageClient interface {
	RoleInfoCreate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*WithID, error)
	RoleInfoIndex(ctx context.Context, in *RoleInfoIndexReq, opts ...grpc.CallOption) (*RoleInfoIndexResp, error)
	RoleInfoUpdate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*Empty, error)
	RoleInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error)
	RoleMenuIndex(ctx context.Context, in *RoleMenuIndexReq, opts ...grpc.CallOption) (*RoleMenuIndexResp, error)
	RoleMenuMultiUpdate(ctx context.Context, in *RoleMenuMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error)
	RoleAppIndex(ctx context.Context, in *RoleAppIndexReq, opts ...grpc.CallOption) (*RoleAppIndexResp, error)
	RoleAppMultiUpdate(ctx context.Context, in *RoleAppMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error)
	RoleModuleIndex(ctx context.Context, in *RoleModuleIndexReq, opts ...grpc.CallOption) (*RoleModuleIndexResp, error)
	RoleModuleMultiUpdate(ctx context.Context, in *RoleModuleMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error)
	RoleApiAuth(ctx context.Context, in *RoleApiAuthReq, opts ...grpc.CallOption) (*Empty, error)
	RoleAccessMultiUpdate(ctx context.Context, in *RoleAccessMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error)
	RoleAccessIndex(ctx context.Context, in *RoleAccessIndexReq, opts ...grpc.CallOption) (*RoleAccessIndexResp, error)
}

type roleManageClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleManageClient(cc grpc.ClientConnInterface) RoleManageClient {
	return &roleManageClient{cc}
}

func (c *roleManageClient) RoleInfoCreate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleInfoIndex(ctx context.Context, in *RoleInfoIndexReq, opts ...grpc.CallOption) (*RoleInfoIndexResp, error) {
	out := new(RoleInfoIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleInfoUpdate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleMenuIndex(ctx context.Context, in *RoleMenuIndexReq, opts ...grpc.CallOption) (*RoleMenuIndexResp, error) {
	out := new(RoleMenuIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleMenuIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleMenuMultiUpdate(ctx context.Context, in *RoleMenuMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, RoleManage_RoleMenuMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleAppIndex(ctx context.Context, in *RoleAppIndexReq, opts ...grpc.CallOption) (*RoleAppIndexResp, error) {
	out := new(RoleAppIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleAppIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleAppMultiUpdate(ctx context.Context, in *RoleAppMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, RoleManage_RoleAppMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleModuleIndex(ctx context.Context, in *RoleModuleIndexReq, opts ...grpc.CallOption) (*RoleModuleIndexResp, error) {
	out := new(RoleModuleIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleModuleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleModuleMultiUpdate(ctx context.Context, in *RoleModuleMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, RoleManage_RoleModuleMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleApiAuth(ctx context.Context, in *RoleApiAuthReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, RoleManage_RoleApiAuth_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleAccessMultiUpdate(ctx context.Context, in *RoleAccessMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, RoleManage_RoleAccessMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleAccessIndex(ctx context.Context, in *RoleAccessIndexReq, opts ...grpc.CallOption) (*RoleAccessIndexResp, error) {
	out := new(RoleAccessIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleAccessIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleManageServer is the server API for RoleManage service.
// All implementations must embed UnimplementedRoleManageServer
// for forward compatibility
type RoleManageServer interface {
	RoleInfoCreate(context.Context, *RoleInfo) (*WithID, error)
	RoleInfoIndex(context.Context, *RoleInfoIndexReq) (*RoleInfoIndexResp, error)
	RoleInfoUpdate(context.Context, *RoleInfo) (*Empty, error)
	RoleInfoDelete(context.Context, *WithID) (*Empty, error)
	RoleMenuIndex(context.Context, *RoleMenuIndexReq) (*RoleMenuIndexResp, error)
	RoleMenuMultiUpdate(context.Context, *RoleMenuMultiUpdateReq) (*Empty, error)
	RoleAppIndex(context.Context, *RoleAppIndexReq) (*RoleAppIndexResp, error)
	RoleAppMultiUpdate(context.Context, *RoleAppMultiUpdateReq) (*Empty, error)
	RoleModuleIndex(context.Context, *RoleModuleIndexReq) (*RoleModuleIndexResp, error)
	RoleModuleMultiUpdate(context.Context, *RoleModuleMultiUpdateReq) (*Empty, error)
	RoleApiAuth(context.Context, *RoleApiAuthReq) (*Empty, error)
	RoleAccessMultiUpdate(context.Context, *RoleAccessMultiUpdateReq) (*Empty, error)
	RoleAccessIndex(context.Context, *RoleAccessIndexReq) (*RoleAccessIndexResp, error)
	mustEmbedUnimplementedRoleManageServer()
}

// UnimplementedRoleManageServer must be embedded to have forward compatible implementations.
type UnimplementedRoleManageServer struct {
}

func (UnimplementedRoleManageServer) RoleInfoCreate(context.Context, *RoleInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoCreate not implemented")
}
func (UnimplementedRoleManageServer) RoleInfoIndex(context.Context, *RoleInfoIndexReq) (*RoleInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleInfoUpdate(context.Context, *RoleInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleInfoDelete(context.Context, *WithID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoDelete not implemented")
}
func (UnimplementedRoleManageServer) RoleMenuIndex(context.Context, *RoleMenuIndexReq) (*RoleMenuIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleMenuIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleMenuMultiUpdate(context.Context, *RoleMenuMultiUpdateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleMenuMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleAppIndex(context.Context, *RoleAppIndexReq) (*RoleAppIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAppIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleAppMultiUpdate(context.Context, *RoleAppMultiUpdateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAppMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleModuleIndex(context.Context, *RoleModuleIndexReq) (*RoleModuleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleModuleIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleModuleMultiUpdate(context.Context, *RoleModuleMultiUpdateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleModuleMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleApiAuth(context.Context, *RoleApiAuthReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiAuth not implemented")
}
func (UnimplementedRoleManageServer) RoleAccessMultiUpdate(context.Context, *RoleAccessMultiUpdateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAccessMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleAccessIndex(context.Context, *RoleAccessIndexReq) (*RoleAccessIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAccessIndex not implemented")
}
func (UnimplementedRoleManageServer) mustEmbedUnimplementedRoleManageServer() {}

// UnsafeRoleManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleManageServer will
// result in compilation errors.
type UnsafeRoleManageServer interface {
	mustEmbedUnimplementedRoleManageServer()
}

func RegisterRoleManageServer(s grpc.ServiceRegistrar, srv RoleManageServer) {
	s.RegisterService(&RoleManage_ServiceDesc, srv)
}

func _RoleManage_RoleInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoCreate(ctx, req.(*RoleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoIndex(ctx, req.(*RoleInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoUpdate(ctx, req.(*RoleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleMenuIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMenuIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleMenuIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleMenuIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleMenuIndex(ctx, req.(*RoleMenuIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleMenuMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMenuMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleMenuMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleMenuMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleMenuMultiUpdate(ctx, req.(*RoleMenuMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleAppIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAppIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleAppIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleAppIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleAppIndex(ctx, req.(*RoleAppIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleAppMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAppMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleAppMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleAppMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleAppMultiUpdate(ctx, req.(*RoleAppMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleModuleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleModuleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleModuleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleModuleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleModuleIndex(ctx, req.(*RoleModuleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleModuleMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleModuleMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleModuleMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleModuleMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleModuleMultiUpdate(ctx, req.(*RoleModuleMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleApiAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiAuthReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleApiAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleApiAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleApiAuth(ctx, req.(*RoleApiAuthReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleAccessMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAccessMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleAccessMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleAccessMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleAccessMultiUpdate(ctx, req.(*RoleAccessMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleAccessIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAccessIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleAccessIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleAccessIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleAccessIndex(ctx, req.(*RoleAccessIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// RoleManage_ServiceDesc is the grpc.ServiceDesc for RoleManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoleManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.RoleManage",
	HandlerType: (*RoleManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "roleInfoCreate",
			Handler:    _RoleManage_RoleInfoCreate_Handler,
		},
		{
			MethodName: "roleInfoIndex",
			Handler:    _RoleManage_RoleInfoIndex_Handler,
		},
		{
			MethodName: "roleInfoUpdate",
			Handler:    _RoleManage_RoleInfoUpdate_Handler,
		},
		{
			MethodName: "roleInfoDelete",
			Handler:    _RoleManage_RoleInfoDelete_Handler,
		},
		{
			MethodName: "roleMenuIndex",
			Handler:    _RoleManage_RoleMenuIndex_Handler,
		},
		{
			MethodName: "roleMenuMultiUpdate",
			Handler:    _RoleManage_RoleMenuMultiUpdate_Handler,
		},
		{
			MethodName: "roleAppIndex",
			Handler:    _RoleManage_RoleAppIndex_Handler,
		},
		{
			MethodName: "roleAppMultiUpdate",
			Handler:    _RoleManage_RoleAppMultiUpdate_Handler,
		},
		{
			MethodName: "roleModuleIndex",
			Handler:    _RoleManage_RoleModuleIndex_Handler,
		},
		{
			MethodName: "roleModuleMultiUpdate",
			Handler:    _RoleManage_RoleModuleMultiUpdate_Handler,
		},
		{
			MethodName: "roleApiAuth",
			Handler:    _RoleManage_RoleApiAuth_Handler,
		},
		{
			MethodName: "roleAccessMultiUpdate",
			Handler:    _RoleManage_RoleAccessMultiUpdate_Handler,
		},
		{
			MethodName: "roleAccessIndex",
			Handler:    _RoleManage_RoleAccessIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	AppManage_AppInfoCreate_FullMethodName        = "/sys.AppManage/appInfoCreate"
	AppManage_AppInfoIndex_FullMethodName         = "/sys.AppManage/appInfoIndex"
	AppManage_AppInfoUpdate_FullMethodName        = "/sys.AppManage/appInfoUpdate"
	AppManage_AppInfoDelete_FullMethodName        = "/sys.AppManage/appInfoDelete"
	AppManage_AppInfoRead_FullMethodName          = "/sys.AppManage/appInfoRead"
	AppManage_AppModuleIndex_FullMethodName       = "/sys.AppManage/appModuleIndex"
	AppManage_AppModuleMultiUpdate_FullMethodName = "/sys.AppManage/appModuleMultiUpdate"
	AppManage_AppPolicyRead_FullMethodName        = "/sys.AppManage/appPolicyRead"
)

// AppManageClient is the client API for AppManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AppManageClient interface {
	AppInfoCreate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*WithID, error)
	AppInfoIndex(ctx context.Context, in *AppInfoIndexReq, opts ...grpc.CallOption) (*AppInfoIndexResp, error)
	AppInfoUpdate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*Empty, error)
	AppInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Empty, error)
	AppInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*AppInfo, error)
	AppModuleIndex(ctx context.Context, in *AppModuleIndexReq, opts ...grpc.CallOption) (*AppModuleIndexResp, error)
	AppModuleMultiUpdate(ctx context.Context, in *AppModuleMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error)
	AppPolicyRead(ctx context.Context, in *AppPolicyReadReq, opts ...grpc.CallOption) (*AppPolicy, error)
}

type appManageClient struct {
	cc grpc.ClientConnInterface
}

func NewAppManageClient(cc grpc.ClientConnInterface) AppManageClient {
	return &appManageClient{cc}
}

func (c *appManageClient) AppInfoCreate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, AppManage_AppInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoIndex(ctx context.Context, in *AppInfoIndexReq, opts ...grpc.CallOption) (*AppInfoIndexResp, error) {
	out := new(AppInfoIndexResp)
	err := c.cc.Invoke(ctx, AppManage_AppInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoUpdate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, AppManage_AppInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, AppManage_AppInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*AppInfo, error) {
	out := new(AppInfo)
	err := c.cc.Invoke(ctx, AppManage_AppInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppModuleIndex(ctx context.Context, in *AppModuleIndexReq, opts ...grpc.CallOption) (*AppModuleIndexResp, error) {
	out := new(AppModuleIndexResp)
	err := c.cc.Invoke(ctx, AppManage_AppModuleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppModuleMultiUpdate(ctx context.Context, in *AppModuleMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, AppManage_AppModuleMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppPolicyRead(ctx context.Context, in *AppPolicyReadReq, opts ...grpc.CallOption) (*AppPolicy, error) {
	out := new(AppPolicy)
	err := c.cc.Invoke(ctx, AppManage_AppPolicyRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppManageServer is the server API for AppManage service.
// All implementations must embed UnimplementedAppManageServer
// for forward compatibility
type AppManageServer interface {
	AppInfoCreate(context.Context, *AppInfo) (*WithID, error)
	AppInfoIndex(context.Context, *AppInfoIndexReq) (*AppInfoIndexResp, error)
	AppInfoUpdate(context.Context, *AppInfo) (*Empty, error)
	AppInfoDelete(context.Context, *WithIDCode) (*Empty, error)
	AppInfoRead(context.Context, *WithIDCode) (*AppInfo, error)
	AppModuleIndex(context.Context, *AppModuleIndexReq) (*AppModuleIndexResp, error)
	AppModuleMultiUpdate(context.Context, *AppModuleMultiUpdateReq) (*Empty, error)
	AppPolicyRead(context.Context, *AppPolicyReadReq) (*AppPolicy, error)
	mustEmbedUnimplementedAppManageServer()
}

// UnimplementedAppManageServer must be embedded to have forward compatible implementations.
type UnimplementedAppManageServer struct {
}

func (UnimplementedAppManageServer) AppInfoCreate(context.Context, *AppInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoCreate not implemented")
}
func (UnimplementedAppManageServer) AppInfoIndex(context.Context, *AppInfoIndexReq) (*AppInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoIndex not implemented")
}
func (UnimplementedAppManageServer) AppInfoUpdate(context.Context, *AppInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoUpdate not implemented")
}
func (UnimplementedAppManageServer) AppInfoDelete(context.Context, *WithIDCode) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoDelete not implemented")
}
func (UnimplementedAppManageServer) AppInfoRead(context.Context, *WithIDCode) (*AppInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoRead not implemented")
}
func (UnimplementedAppManageServer) AppModuleIndex(context.Context, *AppModuleIndexReq) (*AppModuleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppModuleIndex not implemented")
}
func (UnimplementedAppManageServer) AppModuleMultiUpdate(context.Context, *AppModuleMultiUpdateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppModuleMultiUpdate not implemented")
}
func (UnimplementedAppManageServer) AppPolicyRead(context.Context, *AppPolicyReadReq) (*AppPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppPolicyRead not implemented")
}
func (UnimplementedAppManageServer) mustEmbedUnimplementedAppManageServer() {}

// UnsafeAppManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AppManageServer will
// result in compilation errors.
type UnsafeAppManageServer interface {
	mustEmbedUnimplementedAppManageServer()
}

func RegisterAppManageServer(s grpc.ServiceRegistrar, srv AppManageServer) {
	s.RegisterService(&AppManage_ServiceDesc, srv)
}

func _AppManage_AppInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoCreate(ctx, req.(*AppInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoIndex(ctx, req.(*AppInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoUpdate(ctx, req.(*AppInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoDelete(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoRead(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppModuleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppModuleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppModuleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppModuleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppModuleIndex(ctx, req.(*AppModuleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppModuleMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppModuleMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppModuleMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppModuleMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppModuleMultiUpdate(ctx, req.(*AppModuleMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppPolicyRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppPolicyReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppPolicyRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppPolicyRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppPolicyRead(ctx, req.(*AppPolicyReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AppManage_ServiceDesc is the grpc.ServiceDesc for AppManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AppManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.AppManage",
	HandlerType: (*AppManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "appInfoCreate",
			Handler:    _AppManage_AppInfoCreate_Handler,
		},
		{
			MethodName: "appInfoIndex",
			Handler:    _AppManage_AppInfoIndex_Handler,
		},
		{
			MethodName: "appInfoUpdate",
			Handler:    _AppManage_AppInfoUpdate_Handler,
		},
		{
			MethodName: "appInfoDelete",
			Handler:    _AppManage_AppInfoDelete_Handler,
		},
		{
			MethodName: "appInfoRead",
			Handler:    _AppManage_AppInfoRead_Handler,
		},
		{
			MethodName: "appModuleIndex",
			Handler:    _AppManage_AppModuleIndex_Handler,
		},
		{
			MethodName: "appModuleMultiUpdate",
			Handler:    _AppManage_AppModuleMultiUpdate_Handler,
		},
		{
			MethodName: "appPolicyRead",
			Handler:    _AppManage_AppPolicyRead_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	ModuleManage_ModuleInfoCreate_FullMethodName = "/sys.ModuleManage/moduleInfoCreate"
	ModuleManage_ModuleInfoIndex_FullMethodName  = "/sys.ModuleManage/moduleInfoIndex"
	ModuleManage_ModuleInfoUpdate_FullMethodName = "/sys.ModuleManage/moduleInfoUpdate"
	ModuleManage_ModuleInfoDelete_FullMethodName = "/sys.ModuleManage/moduleInfoDelete"
	ModuleManage_ModuleInfoRead_FullMethodName   = "/sys.ModuleManage/moduleInfoRead"
	ModuleManage_ModuleMenuCreate_FullMethodName = "/sys.ModuleManage/moduleMenuCreate"
	ModuleManage_ModuleMenuIndex_FullMethodName  = "/sys.ModuleManage/moduleMenuIndex"
	ModuleManage_ModuleMenuUpdate_FullMethodName = "/sys.ModuleManage/moduleMenuUpdate"
	ModuleManage_ModuleMenuDelete_FullMethodName = "/sys.ModuleManage/moduleMenuDelete"
)

// ModuleManageClient is the client API for ModuleManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ModuleManageClient interface {
	ModuleInfoCreate(ctx context.Context, in *ModuleInfo, opts ...grpc.CallOption) (*WithID, error)
	ModuleInfoIndex(ctx context.Context, in *ModuleInfoIndexReq, opts ...grpc.CallOption) (*ModuleInfoIndexResp, error)
	ModuleInfoUpdate(ctx context.Context, in *ModuleInfo, opts ...grpc.CallOption) (*Empty, error)
	ModuleInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Empty, error)
	ModuleInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*ModuleInfo, error)
	ModuleMenuCreate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*WithID, error)
	ModuleMenuIndex(ctx context.Context, in *MenuInfoIndexReq, opts ...grpc.CallOption) (*MenuInfoIndexResp, error)
	ModuleMenuUpdate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*Empty, error)
	ModuleMenuDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error)
}

type moduleManageClient struct {
	cc grpc.ClientConnInterface
}

func NewModuleManageClient(cc grpc.ClientConnInterface) ModuleManageClient {
	return &moduleManageClient{cc}
}

func (c *moduleManageClient) ModuleInfoCreate(ctx context.Context, in *ModuleInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleInfoIndex(ctx context.Context, in *ModuleInfoIndexReq, opts ...grpc.CallOption) (*ModuleInfoIndexResp, error) {
	out := new(ModuleInfoIndexResp)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleInfoUpdate(ctx context.Context, in *ModuleInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*ModuleInfo, error) {
	out := new(ModuleInfo)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleMenuCreate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleMenuCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleMenuIndex(ctx context.Context, in *MenuInfoIndexReq, opts ...grpc.CallOption) (*MenuInfoIndexResp, error) {
	out := new(MenuInfoIndexResp)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleMenuIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleMenuUpdate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleMenuUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleMenuDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleMenuDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ModuleManageServer is the server API for ModuleManage service.
// All implementations must embed UnimplementedModuleManageServer
// for forward compatibility
type ModuleManageServer interface {
	ModuleInfoCreate(context.Context, *ModuleInfo) (*WithID, error)
	ModuleInfoIndex(context.Context, *ModuleInfoIndexReq) (*ModuleInfoIndexResp, error)
	ModuleInfoUpdate(context.Context, *ModuleInfo) (*Empty, error)
	ModuleInfoDelete(context.Context, *WithIDCode) (*Empty, error)
	ModuleInfoRead(context.Context, *WithIDCode) (*ModuleInfo, error)
	ModuleMenuCreate(context.Context, *MenuInfo) (*WithID, error)
	ModuleMenuIndex(context.Context, *MenuInfoIndexReq) (*MenuInfoIndexResp, error)
	ModuleMenuUpdate(context.Context, *MenuInfo) (*Empty, error)
	ModuleMenuDelete(context.Context, *WithID) (*Empty, error)
	mustEmbedUnimplementedModuleManageServer()
}

// UnimplementedModuleManageServer must be embedded to have forward compatible implementations.
type UnimplementedModuleManageServer struct {
}

func (UnimplementedModuleManageServer) ModuleInfoCreate(context.Context, *ModuleInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoCreate not implemented")
}
func (UnimplementedModuleManageServer) ModuleInfoIndex(context.Context, *ModuleInfoIndexReq) (*ModuleInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoIndex not implemented")
}
func (UnimplementedModuleManageServer) ModuleInfoUpdate(context.Context, *ModuleInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoUpdate not implemented")
}
func (UnimplementedModuleManageServer) ModuleInfoDelete(context.Context, *WithIDCode) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoDelete not implemented")
}
func (UnimplementedModuleManageServer) ModuleInfoRead(context.Context, *WithIDCode) (*ModuleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoRead not implemented")
}
func (UnimplementedModuleManageServer) ModuleMenuCreate(context.Context, *MenuInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleMenuCreate not implemented")
}
func (UnimplementedModuleManageServer) ModuleMenuIndex(context.Context, *MenuInfoIndexReq) (*MenuInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleMenuIndex not implemented")
}
func (UnimplementedModuleManageServer) ModuleMenuUpdate(context.Context, *MenuInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleMenuUpdate not implemented")
}
func (UnimplementedModuleManageServer) ModuleMenuDelete(context.Context, *WithID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleMenuDelete not implemented")
}
func (UnimplementedModuleManageServer) mustEmbedUnimplementedModuleManageServer() {}

// UnsafeModuleManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ModuleManageServer will
// result in compilation errors.
type UnsafeModuleManageServer interface {
	mustEmbedUnimplementedModuleManageServer()
}

func RegisterModuleManageServer(s grpc.ServiceRegistrar, srv ModuleManageServer) {
	s.RegisterService(&ModuleManage_ServiceDesc, srv)
}

func _ModuleManage_ModuleInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoCreate(ctx, req.(*ModuleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoIndex(ctx, req.(*ModuleInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoUpdate(ctx, req.(*ModuleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoDelete(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoRead(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleMenuCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleMenuCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleMenuCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleMenuCreate(ctx, req.(*MenuInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleMenuIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleMenuIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleMenuIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleMenuIndex(ctx, req.(*MenuInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleMenuUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleMenuUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleMenuUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleMenuUpdate(ctx, req.(*MenuInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleMenuDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleMenuDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleMenuDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleMenuDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

// ModuleManage_ServiceDesc is the grpc.ServiceDesc for ModuleManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ModuleManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.ModuleManage",
	HandlerType: (*ModuleManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "moduleInfoCreate",
			Handler:    _ModuleManage_ModuleInfoCreate_Handler,
		},
		{
			MethodName: "moduleInfoIndex",
			Handler:    _ModuleManage_ModuleInfoIndex_Handler,
		},
		{
			MethodName: "moduleInfoUpdate",
			Handler:    _ModuleManage_ModuleInfoUpdate_Handler,
		},
		{
			MethodName: "moduleInfoDelete",
			Handler:    _ModuleManage_ModuleInfoDelete_Handler,
		},
		{
			MethodName: "moduleInfoRead",
			Handler:    _ModuleManage_ModuleInfoRead_Handler,
		},
		{
			MethodName: "moduleMenuCreate",
			Handler:    _ModuleManage_ModuleMenuCreate_Handler,
		},
		{
			MethodName: "moduleMenuIndex",
			Handler:    _ModuleManage_ModuleMenuIndex_Handler,
		},
		{
			MethodName: "moduleMenuUpdate",
			Handler:    _ModuleManage_ModuleMenuUpdate_Handler,
		},
		{
			MethodName: "moduleMenuDelete",
			Handler:    _ModuleManage_ModuleMenuDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	DictManage_DictInfoCreate_FullMethodName   = "/sys.DictManage/dictInfoCreate"
	DictManage_DictInfoIndex_FullMethodName    = "/sys.DictManage/dictInfoIndex"
	DictManage_DictInfoUpdate_FullMethodName   = "/sys.DictManage/dictInfoUpdate"
	DictManage_DictInfoDelete_FullMethodName   = "/sys.DictManage/dictInfoDelete"
	DictManage_DictInfoRead_FullMethodName     = "/sys.DictManage/dictInfoRead"
	DictManage_DictDetailCreate_FullMethodName = "/sys.DictManage/dictDetailCreate"
	DictManage_DictDetailIndex_FullMethodName  = "/sys.DictManage/dictDetailIndex"
	DictManage_DictDetailUpdate_FullMethodName = "/sys.DictManage/dictDetailUpdate"
	DictManage_DictDetailDelete_FullMethodName = "/sys.DictManage/dictDetailDelete"
)

// DictManageClient is the client API for DictManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DictManageClient interface {
	DictInfoCreate(ctx context.Context, in *DictInfo, opts ...grpc.CallOption) (*WithID, error)
	DictInfoIndex(ctx context.Context, in *DictInfoIndexReq, opts ...grpc.CallOption) (*DictInfoIndexResp, error)
	DictInfoUpdate(ctx context.Context, in *DictInfo, opts ...grpc.CallOption) (*Empty, error)
	DictInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error)
	DictInfoRead(ctx context.Context, in *DictInfoReadReq, opts ...grpc.CallOption) (*DictInfo, error)
	DictDetailCreate(ctx context.Context, in *DictDetail, opts ...grpc.CallOption) (*WithID, error)
	DictDetailIndex(ctx context.Context, in *DictDetailIndexReq, opts ...grpc.CallOption) (*DictDetailIndexResp, error)
	DictDetailUpdate(ctx context.Context, in *DictDetail, opts ...grpc.CallOption) (*Empty, error)
	DictDetailDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error)
}

type dictManageClient struct {
	cc grpc.ClientConnInterface
}

func NewDictManageClient(cc grpc.ClientConnInterface) DictManageClient {
	return &dictManageClient{cc}
}

func (c *dictManageClient) DictInfoCreate(ctx context.Context, in *DictInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, DictManage_DictInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictManageClient) DictInfoIndex(ctx context.Context, in *DictInfoIndexReq, opts ...grpc.CallOption) (*DictInfoIndexResp, error) {
	out := new(DictInfoIndexResp)
	err := c.cc.Invoke(ctx, DictManage_DictInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictManageClient) DictInfoUpdate(ctx context.Context, in *DictInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, DictManage_DictInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictManageClient) DictInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, DictManage_DictInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictManageClient) DictInfoRead(ctx context.Context, in *DictInfoReadReq, opts ...grpc.CallOption) (*DictInfo, error) {
	out := new(DictInfo)
	err := c.cc.Invoke(ctx, DictManage_DictInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictManageClient) DictDetailCreate(ctx context.Context, in *DictDetail, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, DictManage_DictDetailCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictManageClient) DictDetailIndex(ctx context.Context, in *DictDetailIndexReq, opts ...grpc.CallOption) (*DictDetailIndexResp, error) {
	out := new(DictDetailIndexResp)
	err := c.cc.Invoke(ctx, DictManage_DictDetailIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictManageClient) DictDetailUpdate(ctx context.Context, in *DictDetail, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, DictManage_DictDetailUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictManageClient) DictDetailDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, DictManage_DictDetailDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DictManageServer is the server API for DictManage service.
// All implementations must embed UnimplementedDictManageServer
// for forward compatibility
type DictManageServer interface {
	DictInfoCreate(context.Context, *DictInfo) (*WithID, error)
	DictInfoIndex(context.Context, *DictInfoIndexReq) (*DictInfoIndexResp, error)
	DictInfoUpdate(context.Context, *DictInfo) (*Empty, error)
	DictInfoDelete(context.Context, *WithID) (*Empty, error)
	DictInfoRead(context.Context, *DictInfoReadReq) (*DictInfo, error)
	DictDetailCreate(context.Context, *DictDetail) (*WithID, error)
	DictDetailIndex(context.Context, *DictDetailIndexReq) (*DictDetailIndexResp, error)
	DictDetailUpdate(context.Context, *DictDetail) (*Empty, error)
	DictDetailDelete(context.Context, *WithID) (*Empty, error)
	mustEmbedUnimplementedDictManageServer()
}

// UnimplementedDictManageServer must be embedded to have forward compatible implementations.
type UnimplementedDictManageServer struct {
}

func (UnimplementedDictManageServer) DictInfoCreate(context.Context, *DictInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictInfoCreate not implemented")
}
func (UnimplementedDictManageServer) DictInfoIndex(context.Context, *DictInfoIndexReq) (*DictInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictInfoIndex not implemented")
}
func (UnimplementedDictManageServer) DictInfoUpdate(context.Context, *DictInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictInfoUpdate not implemented")
}
func (UnimplementedDictManageServer) DictInfoDelete(context.Context, *WithID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictInfoDelete not implemented")
}
func (UnimplementedDictManageServer) DictInfoRead(context.Context, *DictInfoReadReq) (*DictInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictInfoRead not implemented")
}
func (UnimplementedDictManageServer) DictDetailCreate(context.Context, *DictDetail) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictDetailCreate not implemented")
}
func (UnimplementedDictManageServer) DictDetailIndex(context.Context, *DictDetailIndexReq) (*DictDetailIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictDetailIndex not implemented")
}
func (UnimplementedDictManageServer) DictDetailUpdate(context.Context, *DictDetail) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictDetailUpdate not implemented")
}
func (UnimplementedDictManageServer) DictDetailDelete(context.Context, *WithID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictDetailDelete not implemented")
}
func (UnimplementedDictManageServer) mustEmbedUnimplementedDictManageServer() {}

// UnsafeDictManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DictManageServer will
// result in compilation errors.
type UnsafeDictManageServer interface {
	mustEmbedUnimplementedDictManageServer()
}

func RegisterDictManageServer(s grpc.ServiceRegistrar, srv DictManageServer) {
	s.RegisterService(&DictManage_ServiceDesc, srv)
}

func _DictManage_DictInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DictInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictManageServer).DictInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictManage_DictInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictManageServer).DictInfoCreate(ctx, req.(*DictInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictManage_DictInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DictInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictManageServer).DictInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictManage_DictInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictManageServer).DictInfoIndex(ctx, req.(*DictInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictManage_DictInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DictInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictManageServer).DictInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictManage_DictInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictManageServer).DictInfoUpdate(ctx, req.(*DictInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictManage_DictInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictManageServer).DictInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictManage_DictInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictManageServer).DictInfoDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictManage_DictInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DictInfoReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictManageServer).DictInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictManage_DictInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictManageServer).DictInfoRead(ctx, req.(*DictInfoReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictManage_DictDetailCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DictDetail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictManageServer).DictDetailCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictManage_DictDetailCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictManageServer).DictDetailCreate(ctx, req.(*DictDetail))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictManage_DictDetailIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DictDetailIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictManageServer).DictDetailIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictManage_DictDetailIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictManageServer).DictDetailIndex(ctx, req.(*DictDetailIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictManage_DictDetailUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DictDetail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictManageServer).DictDetailUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictManage_DictDetailUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictManageServer).DictDetailUpdate(ctx, req.(*DictDetail))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictManage_DictDetailDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictManageServer).DictDetailDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictManage_DictDetailDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictManageServer).DictDetailDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

// DictManage_ServiceDesc is the grpc.ServiceDesc for DictManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DictManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.DictManage",
	HandlerType: (*DictManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "dictInfoCreate",
			Handler:    _DictManage_DictInfoCreate_Handler,
		},
		{
			MethodName: "dictInfoIndex",
			Handler:    _DictManage_DictInfoIndex_Handler,
		},
		{
			MethodName: "dictInfoUpdate",
			Handler:    _DictManage_DictInfoUpdate_Handler,
		},
		{
			MethodName: "dictInfoDelete",
			Handler:    _DictManage_DictInfoDelete_Handler,
		},
		{
			MethodName: "dictInfoRead",
			Handler:    _DictManage_DictInfoRead_Handler,
		},
		{
			MethodName: "dictDetailCreate",
			Handler:    _DictManage_DictDetailCreate_Handler,
		},
		{
			MethodName: "dictDetailIndex",
			Handler:    _DictManage_DictDetailIndex_Handler,
		},
		{
			MethodName: "dictDetailUpdate",
			Handler:    _DictManage_DictDetailUpdate_Handler,
		},
		{
			MethodName: "dictDetailDelete",
			Handler:    _DictManage_DictDetailDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Common_Config_FullMethodName        = "/sys.Common/config"
	Common_SlotInfoIndex_FullMethodName = "/sys.Common/slotInfoIndex"
)

// CommonClient is the client API for Common service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommonClient interface {
	Config(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ConfigResp, error)
	SlotInfoIndex(ctx context.Context, in *SlotInfoIndexReq, opts ...grpc.CallOption) (*SlotInfoIndexResp, error)
}

type commonClient struct {
	cc grpc.ClientConnInterface
}

func NewCommonClient(cc grpc.ClientConnInterface) CommonClient {
	return &commonClient{cc}
}

func (c *commonClient) Config(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ConfigResp, error) {
	out := new(ConfigResp)
	err := c.cc.Invoke(ctx, Common_Config_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonClient) SlotInfoIndex(ctx context.Context, in *SlotInfoIndexReq, opts ...grpc.CallOption) (*SlotInfoIndexResp, error) {
	out := new(SlotInfoIndexResp)
	err := c.cc.Invoke(ctx, Common_SlotInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommonServer is the server API for Common service.
// All implementations must embed UnimplementedCommonServer
// for forward compatibility
type CommonServer interface {
	Config(context.Context, *Empty) (*ConfigResp, error)
	SlotInfoIndex(context.Context, *SlotInfoIndexReq) (*SlotInfoIndexResp, error)
	mustEmbedUnimplementedCommonServer()
}

// UnimplementedCommonServer must be embedded to have forward compatible implementations.
type UnimplementedCommonServer struct {
}

func (UnimplementedCommonServer) Config(context.Context, *Empty) (*ConfigResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Config not implemented")
}
func (UnimplementedCommonServer) SlotInfoIndex(context.Context, *SlotInfoIndexReq) (*SlotInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SlotInfoIndex not implemented")
}
func (UnimplementedCommonServer) mustEmbedUnimplementedCommonServer() {}

// UnsafeCommonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommonServer will
// result in compilation errors.
type UnsafeCommonServer interface {
	mustEmbedUnimplementedCommonServer()
}

func RegisterCommonServer(s grpc.ServiceRegistrar, srv CommonServer) {
	s.RegisterService(&Common_ServiceDesc, srv)
}

func _Common_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonServer).Config(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Common_Config_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonServer).Config(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Common_SlotInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SlotInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonServer).SlotInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Common_SlotInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonServer).SlotInfoIndex(ctx, req.(*SlotInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Common_ServiceDesc is the grpc.ServiceDesc for Common service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Common_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Common",
	HandlerType: (*CommonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "config",
			Handler:    _Common_Config_Handler,
		},
		{
			MethodName: "slotInfoIndex",
			Handler:    _Common_SlotInfoIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Log_LoginLogIndex_FullMethodName  = "/sys.Log/loginLogIndex"
	Log_OperLogIndex_FullMethodName   = "/sys.Log/operLogIndex"
	Log_LoginLogCreate_FullMethodName = "/sys.Log/loginLogCreate"
	Log_OperLogCreate_FullMethodName  = "/sys.Log/operLogCreate"
)

// LogClient is the client API for Log service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogClient interface {
	LoginLogIndex(ctx context.Context, in *LoginLogIndexReq, opts ...grpc.CallOption) (*LoginLogIndexResp, error)
	OperLogIndex(ctx context.Context, in *OperLogIndexReq, opts ...grpc.CallOption) (*OperLogIndexResp, error)
	LoginLogCreate(ctx context.Context, in *LoginLogCreateReq, opts ...grpc.CallOption) (*Empty, error)
	OperLogCreate(ctx context.Context, in *OperLogCreateReq, opts ...grpc.CallOption) (*Empty, error)
}

type logClient struct {
	cc grpc.ClientConnInterface
}

func NewLogClient(cc grpc.ClientConnInterface) LogClient {
	return &logClient{cc}
}

func (c *logClient) LoginLogIndex(ctx context.Context, in *LoginLogIndexReq, opts ...grpc.CallOption) (*LoginLogIndexResp, error) {
	out := new(LoginLogIndexResp)
	err := c.cc.Invoke(ctx, Log_LoginLogIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) OperLogIndex(ctx context.Context, in *OperLogIndexReq, opts ...grpc.CallOption) (*OperLogIndexResp, error) {
	out := new(OperLogIndexResp)
	err := c.cc.Invoke(ctx, Log_OperLogIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) LoginLogCreate(ctx context.Context, in *LoginLogCreateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Log_LoginLogCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) OperLogCreate(ctx context.Context, in *OperLogCreateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Log_OperLogCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LogServer is the server API for Log service.
// All implementations must embed UnimplementedLogServer
// for forward compatibility
type LogServer interface {
	LoginLogIndex(context.Context, *LoginLogIndexReq) (*LoginLogIndexResp, error)
	OperLogIndex(context.Context, *OperLogIndexReq) (*OperLogIndexResp, error)
	LoginLogCreate(context.Context, *LoginLogCreateReq) (*Empty, error)
	OperLogCreate(context.Context, *OperLogCreateReq) (*Empty, error)
	mustEmbedUnimplementedLogServer()
}

// UnimplementedLogServer must be embedded to have forward compatible implementations.
type UnimplementedLogServer struct {
}

func (UnimplementedLogServer) LoginLogIndex(context.Context, *LoginLogIndexReq) (*LoginLogIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginLogIndex not implemented")
}
func (UnimplementedLogServer) OperLogIndex(context.Context, *OperLogIndexReq) (*OperLogIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperLogIndex not implemented")
}
func (UnimplementedLogServer) LoginLogCreate(context.Context, *LoginLogCreateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginLogCreate not implemented")
}
func (UnimplementedLogServer) OperLogCreate(context.Context, *OperLogCreateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperLogCreate not implemented")
}
func (UnimplementedLogServer) mustEmbedUnimplementedLogServer() {}

// UnsafeLogServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogServer will
// result in compilation errors.
type UnsafeLogServer interface {
	mustEmbedUnimplementedLogServer()
}

func RegisterLogServer(s grpc.ServiceRegistrar, srv LogServer) {
	s.RegisterService(&Log_ServiceDesc, srv)
}

func _Log_LoginLogIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginLogIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).LoginLogIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_LoginLogIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).LoginLogIndex(ctx, req.(*LoginLogIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_OperLogIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperLogIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).OperLogIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_OperLogIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).OperLogIndex(ctx, req.(*OperLogIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_LoginLogCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginLogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).LoginLogCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_LoginLogCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).LoginLogCreate(ctx, req.(*LoginLogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_OperLogCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperLogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).OperLogCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_OperLogCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).OperLogCreate(ctx, req.(*OperLogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Log_ServiceDesc is the grpc.ServiceDesc for Log service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Log_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Log",
	HandlerType: (*LogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "loginLogIndex",
			Handler:    _Log_LoginLogIndex_Handler,
		},
		{
			MethodName: "operLogIndex",
			Handler:    _Log_OperLogIndex_Handler,
		},
		{
			MethodName: "loginLogCreate",
			Handler:    _Log_LoginLogCreate_Handler,
		},
		{
			MethodName: "operLogCreate",
			Handler:    _Log_OperLogCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	ProjectManage_ProjectInfoCreate_FullMethodName = "/sys.ProjectManage/projectInfoCreate"
	ProjectManage_ProjectInfoUpdate_FullMethodName = "/sys.ProjectManage/projectInfoUpdate"
	ProjectManage_ProjectInfoDelete_FullMethodName = "/sys.ProjectManage/projectInfoDelete"
	ProjectManage_ProjectInfoRead_FullMethodName   = "/sys.ProjectManage/projectInfoRead"
	ProjectManage_ProjectInfoIndex_FullMethodName  = "/sys.ProjectManage/projectInfoIndex"
)

// ProjectManageClient is the client API for ProjectManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectManageClient interface {
	// 新增项目
	ProjectInfoCreate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*ProjectWithID, error)
	// 更新项目
	ProjectInfoUpdate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Empty, error)
	// 删除项目
	ProjectInfoDelete(ctx context.Context, in *ProjectWithID, opts ...grpc.CallOption) (*Empty, error)
	// 获取项目信息详情
	ProjectInfoRead(ctx context.Context, in *ProjectWithID, opts ...grpc.CallOption) (*ProjectInfo, error)
	// 获取项目信息列表
	ProjectInfoIndex(ctx context.Context, in *ProjectInfoIndexReq, opts ...grpc.CallOption) (*ProjectInfoIndexResp, error)
}

type projectManageClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectManageClient(cc grpc.ClientConnInterface) ProjectManageClient {
	return &projectManageClient{cc}
}

func (c *projectManageClient) ProjectInfoCreate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*ProjectWithID, error) {
	out := new(ProjectWithID)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoUpdate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoDelete(ctx context.Context, in *ProjectWithID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoRead(ctx context.Context, in *ProjectWithID, opts ...grpc.CallOption) (*ProjectInfo, error) {
	out := new(ProjectInfo)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoIndex(ctx context.Context, in *ProjectInfoIndexReq, opts ...grpc.CallOption) (*ProjectInfoIndexResp, error) {
	out := new(ProjectInfoIndexResp)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectManageServer is the server API for ProjectManage service.
// All implementations must embed UnimplementedProjectManageServer
// for forward compatibility
type ProjectManageServer interface {
	// 新增项目
	ProjectInfoCreate(context.Context, *ProjectInfo) (*ProjectWithID, error)
	// 更新项目
	ProjectInfoUpdate(context.Context, *ProjectInfo) (*Empty, error)
	// 删除项目
	ProjectInfoDelete(context.Context, *ProjectWithID) (*Empty, error)
	// 获取项目信息详情
	ProjectInfoRead(context.Context, *ProjectWithID) (*ProjectInfo, error)
	// 获取项目信息列表
	ProjectInfoIndex(context.Context, *ProjectInfoIndexReq) (*ProjectInfoIndexResp, error)
	mustEmbedUnimplementedProjectManageServer()
}

// UnimplementedProjectManageServer must be embedded to have forward compatible implementations.
type UnimplementedProjectManageServer struct {
}

func (UnimplementedProjectManageServer) ProjectInfoCreate(context.Context, *ProjectInfo) (*ProjectWithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoCreate not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoUpdate(context.Context, *ProjectInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoUpdate not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoDelete(context.Context, *ProjectWithID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoDelete not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoRead(context.Context, *ProjectWithID) (*ProjectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoRead not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoIndex(context.Context, *ProjectInfoIndexReq) (*ProjectInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoIndex not implemented")
}
func (UnimplementedProjectManageServer) mustEmbedUnimplementedProjectManageServer() {}

// UnsafeProjectManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectManageServer will
// result in compilation errors.
type UnsafeProjectManageServer interface {
	mustEmbedUnimplementedProjectManageServer()
}

func RegisterProjectManageServer(s grpc.ServiceRegistrar, srv ProjectManageServer) {
	s.RegisterService(&ProjectManage_ServiceDesc, srv)
}

func _ProjectManage_ProjectInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoCreate(ctx, req.(*ProjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoUpdate(ctx, req.(*ProjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoDelete(ctx, req.(*ProjectWithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoRead(ctx, req.(*ProjectWithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoIndex(ctx, req.(*ProjectInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ProjectManage_ServiceDesc is the grpc.ServiceDesc for ProjectManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProjectManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.ProjectManage",
	HandlerType: (*ProjectManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "projectInfoCreate",
			Handler:    _ProjectManage_ProjectInfoCreate_Handler,
		},
		{
			MethodName: "projectInfoUpdate",
			Handler:    _ProjectManage_ProjectInfoUpdate_Handler,
		},
		{
			MethodName: "projectInfoDelete",
			Handler:    _ProjectManage_ProjectInfoDelete_Handler,
		},
		{
			MethodName: "projectInfoRead",
			Handler:    _ProjectManage_ProjectInfoRead_Handler,
		},
		{
			MethodName: "projectInfoIndex",
			Handler:    _ProjectManage_ProjectInfoIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	AreaManage_AreaInfoCreate_FullMethodName = "/sys.AreaManage/areaInfoCreate"
	AreaManage_AreaInfoUpdate_FullMethodName = "/sys.AreaManage/areaInfoUpdate"
	AreaManage_AreaInfoDelete_FullMethodName = "/sys.AreaManage/areaInfoDelete"
	AreaManage_AreaInfoRead_FullMethodName   = "/sys.AreaManage/areaInfoRead"
	AreaManage_AreaInfoIndex_FullMethodName  = "/sys.AreaManage/areaInfoIndex"
)

// AreaManageClient is the client API for AreaManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AreaManageClient interface {
	// 新增区域
	AreaInfoCreate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*AreaWithID, error)
	// 更新区域
	AreaInfoUpdate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Empty, error)
	// 删除区域
	AreaInfoDelete(ctx context.Context, in *AreaWithID, opts ...grpc.CallOption) (*Empty, error)
	// 获取区域信息详情
	AreaInfoRead(ctx context.Context, in *AreaInfoReadReq, opts ...grpc.CallOption) (*AreaInfo, error)
	// 获取区域信息列表
	AreaInfoIndex(ctx context.Context, in *AreaInfoIndexReq, opts ...grpc.CallOption) (*AreaInfoIndexResp, error)
}

type areaManageClient struct {
	cc grpc.ClientConnInterface
}

func NewAreaManageClient(cc grpc.ClientConnInterface) AreaManageClient {
	return &areaManageClient{cc}
}

func (c *areaManageClient) AreaInfoCreate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*AreaWithID, error) {
	out := new(AreaWithID)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoUpdate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoDelete(ctx context.Context, in *AreaWithID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoRead(ctx context.Context, in *AreaInfoReadReq, opts ...grpc.CallOption) (*AreaInfo, error) {
	out := new(AreaInfo)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoIndex(ctx context.Context, in *AreaInfoIndexReq, opts ...grpc.CallOption) (*AreaInfoIndexResp, error) {
	out := new(AreaInfoIndexResp)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AreaManageServer is the server API for AreaManage service.
// All implementations must embed UnimplementedAreaManageServer
// for forward compatibility
type AreaManageServer interface {
	// 新增区域
	AreaInfoCreate(context.Context, *AreaInfo) (*AreaWithID, error)
	// 更新区域
	AreaInfoUpdate(context.Context, *AreaInfo) (*Empty, error)
	// 删除区域
	AreaInfoDelete(context.Context, *AreaWithID) (*Empty, error)
	// 获取区域信息详情
	AreaInfoRead(context.Context, *AreaInfoReadReq) (*AreaInfo, error)
	// 获取区域信息列表
	AreaInfoIndex(context.Context, *AreaInfoIndexReq) (*AreaInfoIndexResp, error)
	mustEmbedUnimplementedAreaManageServer()
}

// UnimplementedAreaManageServer must be embedded to have forward compatible implementations.
type UnimplementedAreaManageServer struct {
}

func (UnimplementedAreaManageServer) AreaInfoCreate(context.Context, *AreaInfo) (*AreaWithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoCreate not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoUpdate(context.Context, *AreaInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoUpdate not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoDelete(context.Context, *AreaWithID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoDelete not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoRead(context.Context, *AreaInfoReadReq) (*AreaInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoRead not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoIndex(context.Context, *AreaInfoIndexReq) (*AreaInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoIndex not implemented")
}
func (UnimplementedAreaManageServer) mustEmbedUnimplementedAreaManageServer() {}

// UnsafeAreaManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AreaManageServer will
// result in compilation errors.
type UnsafeAreaManageServer interface {
	mustEmbedUnimplementedAreaManageServer()
}

func RegisterAreaManageServer(s grpc.ServiceRegistrar, srv AreaManageServer) {
	s.RegisterService(&AreaManage_ServiceDesc, srv)
}

func _AreaManage_AreaInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoCreate(ctx, req.(*AreaInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoUpdate(ctx, req.(*AreaInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoDelete(ctx, req.(*AreaWithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoRead(ctx, req.(*AreaInfoReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoIndex(ctx, req.(*AreaInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AreaManage_ServiceDesc is the grpc.ServiceDesc for AreaManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AreaManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.AreaManage",
	HandlerType: (*AreaManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "areaInfoCreate",
			Handler:    _AreaManage_AreaInfoCreate_Handler,
		},
		{
			MethodName: "areaInfoUpdate",
			Handler:    _AreaManage_AreaInfoUpdate_Handler,
		},
		{
			MethodName: "areaInfoDelete",
			Handler:    _AreaManage_AreaInfoDelete_Handler,
		},
		{
			MethodName: "areaInfoRead",
			Handler:    _AreaManage_AreaInfoRead_Handler,
		},
		{
			MethodName: "areaInfoIndex",
			Handler:    _AreaManage_AreaInfoIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	TenantManage_TenantInfoCreate_FullMethodName                = "/sys.TenantManage/tenantInfoCreate"
	TenantManage_TenantInfoUpdate_FullMethodName                = "/sys.TenantManage/tenantInfoUpdate"
	TenantManage_TenantInfoDelete_FullMethodName                = "/sys.TenantManage/tenantInfoDelete"
	TenantManage_TenantInfoRead_FullMethodName                  = "/sys.TenantManage/tenantInfoRead"
	TenantManage_TenantInfoIndex_FullMethodName                 = "/sys.TenantManage/tenantInfoIndex"
	TenantManage_TenantAccessMultiUpdate_FullMethodName         = "/sys.TenantManage/tenantAccessMultiUpdate"
	TenantManage_TenantAccessIndex_FullMethodName               = "/sys.TenantManage/tenantAccessIndex"
	TenantManage_TenantAppIndex_FullMethodName                  = "/sys.TenantManage/tenantAppIndex"
	TenantManage_TenantAppCreate_FullMethodName                 = "/sys.TenantManage/tenantAppCreate"
	TenantManage_TenantAppUpdate_FullMethodName                 = "/sys.TenantManage/tenantAppUpdate"
	TenantManage_TenantAppDelete_FullMethodName                 = "/sys.TenantManage/tenantAppDelete"
	TenantManage_TenantAppModuleMultiCreate_FullMethodName      = "/sys.TenantManage/tenantAppModuleMultiCreate"
	TenantManage_TenantAppModuleCreate_FullMethodName           = "/sys.TenantManage/tenantAppModuleCreate"
	TenantManage_TenantAppModuleIndex_FullMethodName            = "/sys.TenantManage/tenantAppModuleIndex"
	TenantManage_TenantAppModuleDelete_FullMethodName           = "/sys.TenantManage/tenantAppModuleDelete"
	TenantManage_TenantAppMenuCreate_FullMethodName             = "/sys.TenantManage/tenantAppMenuCreate"
	TenantManage_TenantAppMenuIndex_FullMethodName              = "/sys.TenantManage/tenantAppMenuIndex"
	TenantManage_TenantAppMenuUpdate_FullMethodName             = "/sys.TenantManage/tenantAppMenuUpdate"
	TenantManage_TenantAppMenuDelete_FullMethodName             = "/sys.TenantManage/tenantAppMenuDelete"
	TenantManage_TenantOpenCheckToken_FullMethodName            = "/sys.TenantManage/tenantOpenCheckToken"
	TenantManage_TenantOpenWebHook_FullMethodName               = "/sys.TenantManage/tenantOpenWebHook"
	TenantManage_TenantNotifyTemplateUpdate_FullMethodName      = "/sys.TenantManage/tenantNotifyTemplateUpdate"
	TenantManage_TenantNotifyTemplateMultiUpdate_FullMethodName = "/sys.TenantManage/tenantNotifyTemplateMultiUpdate"
	TenantManage_TenantNotifyTemplateIndex_FullMethodName       = "/sys.TenantManage/tenantNotifyTemplateIndex"
	TenantManage_TenantNotifyChannelRead_FullMethodName         = "/sys.TenantManage/tenantNotifyChannelRead"
	TenantManage_TenantNotifyChannelCreate_FullMethodName       = "/sys.TenantManage/tenantNotifyChannelCreate"
	TenantManage_TenantNotifyChannelUpdate_FullMethodName       = "/sys.TenantManage/tenantNotifyChannelUpdate"
	TenantManage_TenantNotifyChannelIndex_FullMethodName        = "/sys.TenantManage/tenantNotifyChannelIndex"
	TenantManage_TenantNotifyChannelDelete_FullMethodName       = "/sys.TenantManage/tenantNotifyChannelDelete"
)

// TenantManageClient is the client API for TenantManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TenantManageClient interface {
	// 新增区域
	TenantInfoCreate(ctx context.Context, in *TenantInfoCreateReq, opts ...grpc.CallOption) (*WithID, error)
	// 更新区域
	TenantInfoUpdate(ctx context.Context, in *TenantInfo, opts ...grpc.CallOption) (*Empty, error)
	// 删除区域
	TenantInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Empty, error)
	// 获取租户信息详情
	TenantInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*TenantInfo, error)
	// 获取租户信息列表
	TenantInfoIndex(ctx context.Context, in *TenantInfoIndexReq, opts ...grpc.CallOption) (*TenantInfoIndexResp, error)
	TenantAccessMultiUpdate(ctx context.Context, in *TenantAccessMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error)
	TenantAccessIndex(ctx context.Context, in *TenantAccessIndexReq, opts ...grpc.CallOption) (*TenantAccessIndexResp, error)
	TenantAppIndex(ctx context.Context, in *TenantAppIndexReq, opts ...grpc.CallOption) (*TenantAppIndexResp, error)
	TenantAppCreate(ctx context.Context, in *TenantAppInfo, opts ...grpc.CallOption) (*Empty, error)
	TenantAppUpdate(ctx context.Context, in *TenantAppInfo, opts ...grpc.CallOption) (*Empty, error)
	TenantAppDelete(ctx context.Context, in *TenantAppWithIDOrCode, opts ...grpc.CallOption) (*Empty, error)
	TenantAppModuleMultiCreate(ctx context.Context, in *TenantAppInfo, opts ...grpc.CallOption) (*Empty, error)
	TenantAppModuleCreate(ctx context.Context, in *TenantModuleCreateReq, opts ...grpc.CallOption) (*Empty, error)
	TenantAppModuleIndex(ctx context.Context, in *TenantModuleIndexReq, opts ...grpc.CallOption) (*TenantModuleIndexResp, error)
	TenantAppModuleDelete(ctx context.Context, in *TenantModuleWithIDOrCode, opts ...grpc.CallOption) (*Empty, error)
	TenantAppMenuCreate(ctx context.Context, in *TenantAppMenu, opts ...grpc.CallOption) (*WithID, error)
	TenantAppMenuIndex(ctx context.Context, in *TenantAppMenuIndexReq, opts ...grpc.CallOption) (*TenantAppMenuIndexResp, error)
	TenantAppMenuUpdate(ctx context.Context, in *TenantAppMenu, opts ...grpc.CallOption) (*Empty, error)
	TenantAppMenuDelete(ctx context.Context, in *WithAppCodeID, opts ...grpc.CallOption) (*Empty, error)
	TenantOpenCheckToken(ctx context.Context, in *TenantOpenCheckTokenReq, opts ...grpc.CallOption) (*TenantOpenCheckTokenResp, error)
	TenantOpenWebHook(ctx context.Context, in *WithCode, opts ...grpc.CallOption) (*TenantOpenWebHook, error)
	// 租户通知配置
	TenantNotifyTemplateUpdate(ctx context.Context, in *TenantNotify, opts ...grpc.CallOption) (*Empty, error)
	TenantNotifyTemplateMultiUpdate(ctx context.Context, in *TenantNotifyTemplateMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error)
	TenantNotifyTemplateIndex(ctx context.Context, in *TenantNotifyTemplateIndexReq, opts ...grpc.CallOption) (*TenantNotifyTemplateIndexResp, error)
	TenantNotifyChannelRead(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*TenantNotifyChannel, error)
	TenantNotifyChannelCreate(ctx context.Context, in *TenantNotifyChannel, opts ...grpc.CallOption) (*WithID, error)
	TenantNotifyChannelUpdate(ctx context.Context, in *TenantNotifyChannel, opts ...grpc.CallOption) (*Empty, error)
	TenantNotifyChannelIndex(ctx context.Context, in *TenantNotifyChannelIndexReq, opts ...grpc.CallOption) (*TenantNotifyChannelIndexResp, error)
	TenantNotifyChannelDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error)
}

type tenantManageClient struct {
	cc grpc.ClientConnInterface
}

func NewTenantManageClient(cc grpc.ClientConnInterface) TenantManageClient {
	return &tenantManageClient{cc}
}

func (c *tenantManageClient) TenantInfoCreate(ctx context.Context, in *TenantInfoCreateReq, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoUpdate(ctx context.Context, in *TenantInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*TenantInfo, error) {
	out := new(TenantInfo)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoIndex(ctx context.Context, in *TenantInfoIndexReq, opts ...grpc.CallOption) (*TenantInfoIndexResp, error) {
	out := new(TenantInfoIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAccessMultiUpdate(ctx context.Context, in *TenantAccessMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantAccessMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAccessIndex(ctx context.Context, in *TenantAccessIndexReq, opts ...grpc.CallOption) (*TenantAccessIndexResp, error) {
	out := new(TenantAccessIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAccessIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppIndex(ctx context.Context, in *TenantAppIndexReq, opts ...grpc.CallOption) (*TenantAppIndexResp, error) {
	out := new(TenantAppIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppCreate(ctx context.Context, in *TenantAppInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppUpdate(ctx context.Context, in *TenantAppInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppDelete(ctx context.Context, in *TenantAppWithIDOrCode, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppModuleMultiCreate(ctx context.Context, in *TenantAppInfo, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppModuleMultiCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppModuleCreate(ctx context.Context, in *TenantModuleCreateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppModuleCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppModuleIndex(ctx context.Context, in *TenantModuleIndexReq, opts ...grpc.CallOption) (*TenantModuleIndexResp, error) {
	out := new(TenantModuleIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppModuleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppModuleDelete(ctx context.Context, in *TenantModuleWithIDOrCode, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppModuleDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMenuCreate(ctx context.Context, in *TenantAppMenu, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMenuCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMenuIndex(ctx context.Context, in *TenantAppMenuIndexReq, opts ...grpc.CallOption) (*TenantAppMenuIndexResp, error) {
	out := new(TenantAppMenuIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMenuIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMenuUpdate(ctx context.Context, in *TenantAppMenu, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMenuUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMenuDelete(ctx context.Context, in *WithAppCodeID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMenuDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantOpenCheckToken(ctx context.Context, in *TenantOpenCheckTokenReq, opts ...grpc.CallOption) (*TenantOpenCheckTokenResp, error) {
	out := new(TenantOpenCheckTokenResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantOpenCheckToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantOpenWebHook(ctx context.Context, in *WithCode, opts ...grpc.CallOption) (*TenantOpenWebHook, error) {
	out := new(TenantOpenWebHook)
	err := c.cc.Invoke(ctx, TenantManage_TenantOpenWebHook_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantNotifyTemplateUpdate(ctx context.Context, in *TenantNotify, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantNotifyTemplateUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantNotifyTemplateMultiUpdate(ctx context.Context, in *TenantNotifyTemplateMultiUpdateReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantNotifyTemplateMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantNotifyTemplateIndex(ctx context.Context, in *TenantNotifyTemplateIndexReq, opts ...grpc.CallOption) (*TenantNotifyTemplateIndexResp, error) {
	out := new(TenantNotifyTemplateIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantNotifyTemplateIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantNotifyChannelRead(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*TenantNotifyChannel, error) {
	out := new(TenantNotifyChannel)
	err := c.cc.Invoke(ctx, TenantManage_TenantNotifyChannelRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantNotifyChannelCreate(ctx context.Context, in *TenantNotifyChannel, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, TenantManage_TenantNotifyChannelCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantNotifyChannelUpdate(ctx context.Context, in *TenantNotifyChannel, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantNotifyChannelUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantNotifyChannelIndex(ctx context.Context, in *TenantNotifyChannelIndexReq, opts ...grpc.CallOption) (*TenantNotifyChannelIndexResp, error) {
	out := new(TenantNotifyChannelIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantNotifyChannelIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantNotifyChannelDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, TenantManage_TenantNotifyChannelDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantManageServer is the server API for TenantManage service.
// All implementations must embed UnimplementedTenantManageServer
// for forward compatibility
type TenantManageServer interface {
	// 新增区域
	TenantInfoCreate(context.Context, *TenantInfoCreateReq) (*WithID, error)
	// 更新区域
	TenantInfoUpdate(context.Context, *TenantInfo) (*Empty, error)
	// 删除区域
	TenantInfoDelete(context.Context, *WithIDCode) (*Empty, error)
	// 获取租户信息详情
	TenantInfoRead(context.Context, *WithIDCode) (*TenantInfo, error)
	// 获取租户信息列表
	TenantInfoIndex(context.Context, *TenantInfoIndexReq) (*TenantInfoIndexResp, error)
	TenantAccessMultiUpdate(context.Context, *TenantAccessMultiUpdateReq) (*Empty, error)
	TenantAccessIndex(context.Context, *TenantAccessIndexReq) (*TenantAccessIndexResp, error)
	TenantAppIndex(context.Context, *TenantAppIndexReq) (*TenantAppIndexResp, error)
	TenantAppCreate(context.Context, *TenantAppInfo) (*Empty, error)
	TenantAppUpdate(context.Context, *TenantAppInfo) (*Empty, error)
	TenantAppDelete(context.Context, *TenantAppWithIDOrCode) (*Empty, error)
	TenantAppModuleMultiCreate(context.Context, *TenantAppInfo) (*Empty, error)
	TenantAppModuleCreate(context.Context, *TenantModuleCreateReq) (*Empty, error)
	TenantAppModuleIndex(context.Context, *TenantModuleIndexReq) (*TenantModuleIndexResp, error)
	TenantAppModuleDelete(context.Context, *TenantModuleWithIDOrCode) (*Empty, error)
	TenantAppMenuCreate(context.Context, *TenantAppMenu) (*WithID, error)
	TenantAppMenuIndex(context.Context, *TenantAppMenuIndexReq) (*TenantAppMenuIndexResp, error)
	TenantAppMenuUpdate(context.Context, *TenantAppMenu) (*Empty, error)
	TenantAppMenuDelete(context.Context, *WithAppCodeID) (*Empty, error)
	TenantOpenCheckToken(context.Context, *TenantOpenCheckTokenReq) (*TenantOpenCheckTokenResp, error)
	TenantOpenWebHook(context.Context, *WithCode) (*TenantOpenWebHook, error)
	// 租户通知配置
	TenantNotifyTemplateUpdate(context.Context, *TenantNotify) (*Empty, error)
	TenantNotifyTemplateMultiUpdate(context.Context, *TenantNotifyTemplateMultiUpdateReq) (*Empty, error)
	TenantNotifyTemplateIndex(context.Context, *TenantNotifyTemplateIndexReq) (*TenantNotifyTemplateIndexResp, error)
	TenantNotifyChannelRead(context.Context, *WithID) (*TenantNotifyChannel, error)
	TenantNotifyChannelCreate(context.Context, *TenantNotifyChannel) (*WithID, error)
	TenantNotifyChannelUpdate(context.Context, *TenantNotifyChannel) (*Empty, error)
	TenantNotifyChannelIndex(context.Context, *TenantNotifyChannelIndexReq) (*TenantNotifyChannelIndexResp, error)
	TenantNotifyChannelDelete(context.Context, *WithID) (*Empty, error)
	mustEmbedUnimplementedTenantManageServer()
}

// UnimplementedTenantManageServer must be embedded to have forward compatible implementations.
type UnimplementedTenantManageServer struct {
}

func (UnimplementedTenantManageServer) TenantInfoCreate(context.Context, *TenantInfoCreateReq) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoUpdate(context.Context, *TenantInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoDelete(context.Context, *WithIDCode) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoDelete not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoRead(context.Context, *WithIDCode) (*TenantInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoRead not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoIndex(context.Context, *TenantInfoIndexReq) (*TenantInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAccessMultiUpdate(context.Context, *TenantAccessMultiUpdateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAccessMultiUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantAccessIndex(context.Context, *TenantAccessIndexReq) (*TenantAccessIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAccessIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppIndex(context.Context, *TenantAppIndexReq) (*TenantAppIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppCreate(context.Context, *TenantAppInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppUpdate(context.Context, *TenantAppInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppDelete(context.Context, *TenantAppWithIDOrCode) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppDelete not implemented")
}
func (UnimplementedTenantManageServer) TenantAppModuleMultiCreate(context.Context, *TenantAppInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppModuleMultiCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppModuleCreate(context.Context, *TenantModuleCreateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppModuleCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppModuleIndex(context.Context, *TenantModuleIndexReq) (*TenantModuleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppModuleIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppModuleDelete(context.Context, *TenantModuleWithIDOrCode) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppModuleDelete not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMenuCreate(context.Context, *TenantAppMenu) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMenuCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMenuIndex(context.Context, *TenantAppMenuIndexReq) (*TenantAppMenuIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMenuIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMenuUpdate(context.Context, *TenantAppMenu) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMenuUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMenuDelete(context.Context, *WithAppCodeID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMenuDelete not implemented")
}
func (UnimplementedTenantManageServer) TenantOpenCheckToken(context.Context, *TenantOpenCheckTokenReq) (*TenantOpenCheckTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantOpenCheckToken not implemented")
}
func (UnimplementedTenantManageServer) TenantOpenWebHook(context.Context, *WithCode) (*TenantOpenWebHook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantOpenWebHook not implemented")
}
func (UnimplementedTenantManageServer) TenantNotifyTemplateUpdate(context.Context, *TenantNotify) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantNotifyTemplateUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantNotifyTemplateMultiUpdate(context.Context, *TenantNotifyTemplateMultiUpdateReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantNotifyTemplateMultiUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantNotifyTemplateIndex(context.Context, *TenantNotifyTemplateIndexReq) (*TenantNotifyTemplateIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantNotifyTemplateIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantNotifyChannelRead(context.Context, *WithID) (*TenantNotifyChannel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantNotifyChannelRead not implemented")
}
func (UnimplementedTenantManageServer) TenantNotifyChannelCreate(context.Context, *TenantNotifyChannel) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantNotifyChannelCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantNotifyChannelUpdate(context.Context, *TenantNotifyChannel) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantNotifyChannelUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantNotifyChannelIndex(context.Context, *TenantNotifyChannelIndexReq) (*TenantNotifyChannelIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantNotifyChannelIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantNotifyChannelDelete(context.Context, *WithID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantNotifyChannelDelete not implemented")
}
func (UnimplementedTenantManageServer) mustEmbedUnimplementedTenantManageServer() {}

// UnsafeTenantManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TenantManageServer will
// result in compilation errors.
type UnsafeTenantManageServer interface {
	mustEmbedUnimplementedTenantManageServer()
}

func RegisterTenantManageServer(s grpc.ServiceRegistrar, srv TenantManageServer) {
	s.RegisterService(&TenantManage_ServiceDesc, srv)
}

func _TenantManage_TenantInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfoCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoCreate(ctx, req.(*TenantInfoCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoUpdate(ctx, req.(*TenantInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoDelete(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoRead(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoIndex(ctx, req.(*TenantInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAccessMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAccessMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAccessMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAccessMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAccessMultiUpdate(ctx, req.(*TenantAccessMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAccessIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAccessIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAccessIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAccessIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAccessIndex(ctx, req.(*TenantAccessIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppIndex(ctx, req.(*TenantAppIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppCreate(ctx, req.(*TenantAppInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppUpdate(ctx, req.(*TenantAppInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppWithIDOrCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppDelete(ctx, req.(*TenantAppWithIDOrCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppModuleMultiCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppModuleMultiCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppModuleMultiCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppModuleMultiCreate(ctx, req.(*TenantAppInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppModuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantModuleCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppModuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppModuleCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppModuleCreate(ctx, req.(*TenantModuleCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppModuleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantModuleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppModuleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppModuleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppModuleIndex(ctx, req.(*TenantModuleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppModuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantModuleWithIDOrCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppModuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppModuleDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppModuleDelete(ctx, req.(*TenantModuleWithIDOrCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMenuCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppMenu)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMenuCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMenuCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMenuCreate(ctx, req.(*TenantAppMenu))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMenuIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppMenuIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMenuIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMenuIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMenuIndex(ctx, req.(*TenantAppMenuIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMenuUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppMenu)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMenuUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMenuUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMenuUpdate(ctx, req.(*TenantAppMenu))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMenuDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithAppCodeID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMenuDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMenuDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMenuDelete(ctx, req.(*WithAppCodeID))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantOpenCheckToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantOpenCheckTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantOpenCheckToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantOpenCheckToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantOpenCheckToken(ctx, req.(*TenantOpenCheckTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantOpenWebHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantOpenWebHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantOpenWebHook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantOpenWebHook(ctx, req.(*WithCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantNotifyTemplateUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantNotify)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantNotifyTemplateUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantNotifyTemplateUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantNotifyTemplateUpdate(ctx, req.(*TenantNotify))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantNotifyTemplateMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantNotifyTemplateMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantNotifyTemplateMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantNotifyTemplateMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantNotifyTemplateMultiUpdate(ctx, req.(*TenantNotifyTemplateMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantNotifyTemplateIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantNotifyTemplateIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantNotifyTemplateIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantNotifyTemplateIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantNotifyTemplateIndex(ctx, req.(*TenantNotifyTemplateIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantNotifyChannelRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantNotifyChannelRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantNotifyChannelRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantNotifyChannelRead(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantNotifyChannelCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantNotifyChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantNotifyChannelCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantNotifyChannelCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantNotifyChannelCreate(ctx, req.(*TenantNotifyChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantNotifyChannelUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantNotifyChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantNotifyChannelUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantNotifyChannelUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantNotifyChannelUpdate(ctx, req.(*TenantNotifyChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantNotifyChannelIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantNotifyChannelIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantNotifyChannelIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantNotifyChannelIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantNotifyChannelIndex(ctx, req.(*TenantNotifyChannelIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantNotifyChannelDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantNotifyChannelDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantNotifyChannelDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantNotifyChannelDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

// TenantManage_ServiceDesc is the grpc.ServiceDesc for TenantManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TenantManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.TenantManage",
	HandlerType: (*TenantManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "tenantInfoCreate",
			Handler:    _TenantManage_TenantInfoCreate_Handler,
		},
		{
			MethodName: "tenantInfoUpdate",
			Handler:    _TenantManage_TenantInfoUpdate_Handler,
		},
		{
			MethodName: "tenantInfoDelete",
			Handler:    _TenantManage_TenantInfoDelete_Handler,
		},
		{
			MethodName: "tenantInfoRead",
			Handler:    _TenantManage_TenantInfoRead_Handler,
		},
		{
			MethodName: "tenantInfoIndex",
			Handler:    _TenantManage_TenantInfoIndex_Handler,
		},
		{
			MethodName: "tenantAccessMultiUpdate",
			Handler:    _TenantManage_TenantAccessMultiUpdate_Handler,
		},
		{
			MethodName: "tenantAccessIndex",
			Handler:    _TenantManage_TenantAccessIndex_Handler,
		},
		{
			MethodName: "tenantAppIndex",
			Handler:    _TenantManage_TenantAppIndex_Handler,
		},
		{
			MethodName: "tenantAppCreate",
			Handler:    _TenantManage_TenantAppCreate_Handler,
		},
		{
			MethodName: "tenantAppUpdate",
			Handler:    _TenantManage_TenantAppUpdate_Handler,
		},
		{
			MethodName: "tenantAppDelete",
			Handler:    _TenantManage_TenantAppDelete_Handler,
		},
		{
			MethodName: "tenantAppModuleMultiCreate",
			Handler:    _TenantManage_TenantAppModuleMultiCreate_Handler,
		},
		{
			MethodName: "tenantAppModuleCreate",
			Handler:    _TenantManage_TenantAppModuleCreate_Handler,
		},
		{
			MethodName: "tenantAppModuleIndex",
			Handler:    _TenantManage_TenantAppModuleIndex_Handler,
		},
		{
			MethodName: "tenantAppModuleDelete",
			Handler:    _TenantManage_TenantAppModuleDelete_Handler,
		},
		{
			MethodName: "tenantAppMenuCreate",
			Handler:    _TenantManage_TenantAppMenuCreate_Handler,
		},
		{
			MethodName: "tenantAppMenuIndex",
			Handler:    _TenantManage_TenantAppMenuIndex_Handler,
		},
		{
			MethodName: "tenantAppMenuUpdate",
			Handler:    _TenantManage_TenantAppMenuUpdate_Handler,
		},
		{
			MethodName: "tenantAppMenuDelete",
			Handler:    _TenantManage_TenantAppMenuDelete_Handler,
		},
		{
			MethodName: "tenantOpenCheckToken",
			Handler:    _TenantManage_TenantOpenCheckToken_Handler,
		},
		{
			MethodName: "tenantOpenWebHook",
			Handler:    _TenantManage_TenantOpenWebHook_Handler,
		},
		{
			MethodName: "tenantNotifyTemplateUpdate",
			Handler:    _TenantManage_TenantNotifyTemplateUpdate_Handler,
		},
		{
			MethodName: "tenantNotifyTemplateMultiUpdate",
			Handler:    _TenantManage_TenantNotifyTemplateMultiUpdate_Handler,
		},
		{
			MethodName: "tenantNotifyTemplateIndex",
			Handler:    _TenantManage_TenantNotifyTemplateIndex_Handler,
		},
		{
			MethodName: "tenantNotifyChannelRead",
			Handler:    _TenantManage_TenantNotifyChannelRead_Handler,
		},
		{
			MethodName: "tenantNotifyChannelCreate",
			Handler:    _TenantManage_TenantNotifyChannelCreate_Handler,
		},
		{
			MethodName: "tenantNotifyChannelUpdate",
			Handler:    _TenantManage_TenantNotifyChannelUpdate_Handler,
		},
		{
			MethodName: "tenantNotifyChannelIndex",
			Handler:    _TenantManage_TenantNotifyChannelIndex_Handler,
		},
		{
			MethodName: "tenantNotifyChannelDelete",
			Handler:    _TenantManage_TenantNotifyChannelDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Ops_OpsWorkOrderCreate_FullMethodName = "/sys.ops/opsWorkOrderCreate"
	Ops_OpsWorkOrderUpdate_FullMethodName = "/sys.ops/opsWorkOrderUpdate"
	Ops_OpsWorkOrderIndex_FullMethodName  = "/sys.ops/opsWorkOrderIndex"
	Ops_OpsFeedbackCreate_FullMethodName  = "/sys.ops/opsFeedbackCreate"
	Ops_OpsFeedbackIndex_FullMethodName   = "/sys.ops/opsFeedbackIndex"
)

// OpsClient is the client API for Ops service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OpsClient interface {
	// 维护工单  Work Order
	OpsWorkOrderCreate(ctx context.Context, in *OpsWorkOrder, opts ...grpc.CallOption) (*WithID, error)
	OpsWorkOrderUpdate(ctx context.Context, in *OpsWorkOrder, opts ...grpc.CallOption) (*Empty, error)
	OpsWorkOrderIndex(ctx context.Context, in *OpsWorkOrderIndexReq, opts ...grpc.CallOption) (*OpsWorkOrderIndexResp, error)
	OpsFeedbackCreate(ctx context.Context, in *OpsFeedback, opts ...grpc.CallOption) (*WithID, error)
	OpsFeedbackIndex(ctx context.Context, in *OpsFeedbackIndexReq, opts ...grpc.CallOption) (*OpsFeedbackIndexResp, error)
}

type opsClient struct {
	cc grpc.ClientConnInterface
}

func NewOpsClient(cc grpc.ClientConnInterface) OpsClient {
	return &opsClient{cc}
}

func (c *opsClient) OpsWorkOrderCreate(ctx context.Context, in *OpsWorkOrder, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, Ops_OpsWorkOrderCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *opsClient) OpsWorkOrderUpdate(ctx context.Context, in *OpsWorkOrder, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, Ops_OpsWorkOrderUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *opsClient) OpsWorkOrderIndex(ctx context.Context, in *OpsWorkOrderIndexReq, opts ...grpc.CallOption) (*OpsWorkOrderIndexResp, error) {
	out := new(OpsWorkOrderIndexResp)
	err := c.cc.Invoke(ctx, Ops_OpsWorkOrderIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *opsClient) OpsFeedbackCreate(ctx context.Context, in *OpsFeedback, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, Ops_OpsFeedbackCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *opsClient) OpsFeedbackIndex(ctx context.Context, in *OpsFeedbackIndexReq, opts ...grpc.CallOption) (*OpsFeedbackIndexResp, error) {
	out := new(OpsFeedbackIndexResp)
	err := c.cc.Invoke(ctx, Ops_OpsFeedbackIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OpsServer is the server API for Ops service.
// All implementations must embed UnimplementedOpsServer
// for forward compatibility
type OpsServer interface {
	// 维护工单  Work Order
	OpsWorkOrderCreate(context.Context, *OpsWorkOrder) (*WithID, error)
	OpsWorkOrderUpdate(context.Context, *OpsWorkOrder) (*Empty, error)
	OpsWorkOrderIndex(context.Context, *OpsWorkOrderIndexReq) (*OpsWorkOrderIndexResp, error)
	OpsFeedbackCreate(context.Context, *OpsFeedback) (*WithID, error)
	OpsFeedbackIndex(context.Context, *OpsFeedbackIndexReq) (*OpsFeedbackIndexResp, error)
	mustEmbedUnimplementedOpsServer()
}

// UnimplementedOpsServer must be embedded to have forward compatible implementations.
type UnimplementedOpsServer struct {
}

func (UnimplementedOpsServer) OpsWorkOrderCreate(context.Context, *OpsWorkOrder) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpsWorkOrderCreate not implemented")
}
func (UnimplementedOpsServer) OpsWorkOrderUpdate(context.Context, *OpsWorkOrder) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpsWorkOrderUpdate not implemented")
}
func (UnimplementedOpsServer) OpsWorkOrderIndex(context.Context, *OpsWorkOrderIndexReq) (*OpsWorkOrderIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpsWorkOrderIndex not implemented")
}
func (UnimplementedOpsServer) OpsFeedbackCreate(context.Context, *OpsFeedback) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpsFeedbackCreate not implemented")
}
func (UnimplementedOpsServer) OpsFeedbackIndex(context.Context, *OpsFeedbackIndexReq) (*OpsFeedbackIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpsFeedbackIndex not implemented")
}
func (UnimplementedOpsServer) mustEmbedUnimplementedOpsServer() {}

// UnsafeOpsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OpsServer will
// result in compilation errors.
type UnsafeOpsServer interface {
	mustEmbedUnimplementedOpsServer()
}

func RegisterOpsServer(s grpc.ServiceRegistrar, srv OpsServer) {
	s.RegisterService(&Ops_ServiceDesc, srv)
}

func _Ops_OpsWorkOrderCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpsWorkOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpsServer).OpsWorkOrderCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Ops_OpsWorkOrderCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpsServer).OpsWorkOrderCreate(ctx, req.(*OpsWorkOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ops_OpsWorkOrderUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpsWorkOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpsServer).OpsWorkOrderUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Ops_OpsWorkOrderUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpsServer).OpsWorkOrderUpdate(ctx, req.(*OpsWorkOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ops_OpsWorkOrderIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpsWorkOrderIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpsServer).OpsWorkOrderIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Ops_OpsWorkOrderIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpsServer).OpsWorkOrderIndex(ctx, req.(*OpsWorkOrderIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ops_OpsFeedbackCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpsFeedback)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpsServer).OpsFeedbackCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Ops_OpsFeedbackCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpsServer).OpsFeedbackCreate(ctx, req.(*OpsFeedback))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ops_OpsFeedbackIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpsFeedbackIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpsServer).OpsFeedbackIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Ops_OpsFeedbackIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpsServer).OpsFeedbackIndex(ctx, req.(*OpsFeedbackIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Ops_ServiceDesc is the grpc.ServiceDesc for Ops service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Ops_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.ops",
	HandlerType: (*OpsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "opsWorkOrderCreate",
			Handler:    _Ops_OpsWorkOrderCreate_Handler,
		},
		{
			MethodName: "opsWorkOrderUpdate",
			Handler:    _Ops_OpsWorkOrderUpdate_Handler,
		},
		{
			MethodName: "opsWorkOrderIndex",
			Handler:    _Ops_OpsWorkOrderIndex_Handler,
		},
		{
			MethodName: "opsFeedbackCreate",
			Handler:    _Ops_OpsFeedbackCreate_Handler,
		},
		{
			MethodName: "opsFeedbackIndex",
			Handler:    _Ops_OpsFeedbackIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}
